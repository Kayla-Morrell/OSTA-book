[["index.html", "Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor Welcome", " Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor 2021-06-09 Welcome This is the website for the online textbook “Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor” (OSTA). This book describes the steps in a computational analysis pipeline for spatially resolved transcriptomics (ST) data, using the Bioconductor framework and R programming language. The analysis pipeline is built up as a series of steps, each described in a chapter, with complete examples and workflows using R code and datasets that can be run on your own laptop. The book is organized into several parts, consisting of (i) introduction, (ii) preprocessing steps to prepare data for R, (iii) analysis steps, (iv) complete workflows, and (v) appendix. Additional details on analysis steps, as well as additional introductory material on R and Bioconductor, can be found in the related textbook Orchestrating Single-Cell Analysis with Bioconductor (OSCA). "],["introduction.html", "Chapter 1 Introduction 1.1 Contents of this book 1.2 Who this book is for 1.3 Bioconductor", " Chapter 1 Introduction This book describes a computational analysis pipeline for spatially resolved transcriptomics (ST) data, using the Bioconductor framework and R programming language. 1.1 Contents of this book The chapters are organized into several parts: Introduction: introduction, spatially resolved transcriptomics, and the SpatialExperiment object class Preprocessing steps: preprocessing steps to prepare raw data for loading into R Analysis steps: chapters describing key analysis steps using the Bioconductor framework, including examples of R code that can be run on your own laptop Workflows: complete workflows for several example datasets Appendix: contributors, acknowledgments, references 1.2 Who this book is for This book is intended for readers who have some experience with R, but does not assume any previous familiarity with Bioconductor. The examples and workflows include all R code required to download data, set up data objects, perform analyses, and visualize results. For readers who are new to R and Bioconductor, additional useful resources include: The Orchestrating Single-Cell Analysis with Bioconductor (OSCA) book, which contains additional details on the analysis steps described here in the context of single-cell RNA sequencing instead of ST data, as well as additional introductory chapters on R and Bioconductor The R for Data Science online textbook provides an excellent introduction to R Data Carpentry and Software Carpentry provide both introductory and more advanced online lesson materials on R programming, as well as the Unix shell and Git 1.3 Bioconductor Bioconductor is an open source and open development project, providing a cohesive and flexible framework for analyzing high-throughput genomics data in R. The Bioconductor project consists of around 2000 contributed R packages, as well as core infrastructure maintained by the Bioconductor Core Team, providing a rich analysis environment for users. One of the main advantages of Bioconductor is the modularity and open development philosophy. R packages implementing analysis methods are contributed by numerous research groups, with the Bioconductor Core Team coordinating the overall project and maintaining infrastructure such as data class structures and package testing infrastructure. A key feature is that contributed packages use consistent data structures, such as SingleCellExperiment or SpatialExperiment, which allows packages to interact nicely (e.g. output from one package can easily be provided as input to another package). In addition, contributed Bioconductor packages are expected to have comprehensive documentation, including vignettes (long-form examples including R code). This modular and open-development approach allows end users to readily combine and substitute analysis methods contributed by different research groups, instead of being “locked in” to using methods or packages maintained by a single group. In a fast-moving field such as single-cell or ST analysis, having the ability to update analysis pipelines to use the latest methods is a crucial advantage. Any research group can contribute new packages implementing new methods to Bioconductor by following the contribution guidelines. "],["spatially-resolved-transcriptomics.html", "Chapter 2 Spatially resolved transcriptomics 2.1 10x Genomics Visium", " Chapter 2 Spatially resolved transcriptomics Spatially resolved transcriptomics (ST) technologies allow transcriptome-wide gene expression to be measured at spatial resolution. There are several technological platforms, each with their unique advantages. Here we describe the platforms used to generate the example datasets in this book. 2.1 10x Genomics Visium The 10x Genomics Visium platform measures transcriptome-wide gene expression at a two-dimensional grid of “spots” on a tissue slide. Fresh-frozen tissue is placed onto the slide, fixed, stained, and permeabilized. Each spot contains millions of spatially-barcoded capture oligonucleotides, which bind to mRNAs from the tissue. A cDNA library is then generated for sequencing, which includes the spatial barcodes, allowing reads to be mapped back to their spatial locations. The dimensions of the tissue slide are approximately 6.5mm by 6.5mm, and contains around 5000 barcoded spots. Spots are located in a regular hexagonal arrangement, with each spot 55µm in diameter, and 100µm center to center. The number of cells per spot depends on the organism and tissue type, e.g. 0-10 for human brain, or around 50 for mouse brain. Each slide contains 4 capture areas (6.5mm x 6.5mm each). The following figure provides an illustration. This platform is commercially available from 10x Genomics, making it relatively accessible, affordable, and easy for new labs to get started with, especially compared to platforms that require more specialized equipment and expertise. In our view, this makes it likely that Visium (and its future extensions) will see widespread adoption over the coming years. Figure 2.1: Schematic of 10x Genomics Visium platform. Image source: 10x Genomics Visium website "],["spatialexperiment.html", "Chapter 3 SpatialExperiment 3.1 SpatialExperiment class", " Chapter 3 SpatialExperiment In this book, we use the SpatialExperiment class from Bioconductor as the main data structure for storing and manipulating datasets. 3.1 SpatialExperiment class SpatialExperiment is a specialized object class for storing spatially resolved transcriptomics datasets from several technological platforms within the Bioconductor framework. The class builds on the more general SingleCellExperiment class for single-cell RNA sequencing data, with additional customizations to store spatial information, such as spatial coordinates and image files. A summary of the SpatialExperiment object structure is show in the following figure. Briefly, a SpatialExperiment object consists of (i) assays containing expression counts, (ii) rowData containing information on features, i.e. genes, (iii) colData containing information on spots or cells, (iv) spatialData and spatialCoords containing spatial coordinates and other spatial information, and (v) imgData containing information on image files. For spot-based ST data (e.g. 10x Genomics Visium), a single assay named counts is used. For molecule-based ST data (e.g. seqFISH), two assays named counts and molecules are used. For more details, see our preprint SpatialExperiment: infrastructure for spatially resolved transcriptomics data in R using Bioconductor. Figure 3.1: Overview of the SpatialExperiment object class for storing spatially resolved transcriptomics datasets in the Bioconductor framework. "],["preprocessing-steps.html", "Chapter 4 Preprocessing steps", " Chapter 4 Preprocessing steps In this part, we describe several crucial preprocessing steps required to prepare raw data files to load the data into R. These steps require the use of several tools outside Bioconductor. In the examples, we primarily focus on data from the 10x Genomics Visium platform. "],["image-segmentation-visium.html", "Chapter 5 Image segmentation (Visium) 5.1 Overview 5.2 Split histology images 5.3 File size issues 5.4 Segment cell nuclei 5.5 Identify number of cells per spot 5.6 Output files", " Chapter 5 Image segmentation (Visium) 5.1 Overview 5.2 Split histology images 5.3 File size issues 5.4 Segment cell nuclei 5.5 Identify number of cells per spot 5.6 Output files "],["loupe-browser-visium.html", "Chapter 6 Loupe Browser (Visium) 6.1 Overview 6.2 Automatic alignment of images 6.3 Manual alignment of images 6.4 Output files for Space Ranger 6.5 Downstream analyses in Loupe Browser", " Chapter 6 Loupe Browser (Visium) 6.1 Overview 6.2 Automatic alignment of images 6.3 Manual alignment of images 6.4 Output files for Space Ranger 6.5 Downstream analyses in Loupe Browser "],["space-ranger-visium.html", "Chapter 7 Space Ranger (Visium) 7.1 Overview 7.2 Installation 7.3 Memory issues 7.4 Run spaceranger count 7.5 Output files 7.6 Web summary .html file 7.7 Import outputs into R", " Chapter 7 Space Ranger (Visium) 7.1 Overview 7.2 Installation 7.3 Memory issues 7.4 Run spaceranger count 7.5 Output files 7.6 Web summary .html file 7.7 Import outputs into R "],["analysis-steps.html", "Chapter 8 Analysis steps 8.1 Load data 8.2 SpatialExperiment object structure", " Chapter 8 Analysis steps This part consists of several chapters for steps in a computational analysis pipeline for spatially resolved transcriptomics (ST) data. This includes quality control (QC), normalization, feature selection, dimensionality reduction, clustering, and identifying marker genes. These steps require that the raw data has been loaded into R. In the previous part, we provide instructions and examples showing how to do this for the 10x Genomics Visium platform. Throughout these chapters, we follow the Bioconductor principle of modularity – for steps where multiple alternative analysis tools exist, we show how to substitute these, using the SpatialExperiment class to store input and output objects. 8.1 Load data In the following analysis chapters, we use a pre-prepared dataset where we have previously applied the steps described in Preprocessing steps, and saved the object in the SpatialExperiment format. This is available from the STexampleData package. The dataset consists of a single sample of human brain from the dorsolateral prefrontal cortex (DLPFC) region, measured using the 10x Genomics Visium platform, from our publication Maynard et al. (2021). The dataset is described in more detail in Visium human DLPFC workflow. Here, we show how to load the data from the STexampleData package. library(SpatialExperiment) library(STexampleData) # load object spe &lt;- Visium_humanDLPFC() 8.2 SpatialExperiment object structure Next, we inspect the SpatialExperiment object. For more details, see SpatialExperiment. # check object spe ## class: SpatialExperiment ## dim: 33538 4992 ## metadata(0): ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): gene_id gene_name feature_type ## colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... ## TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 ## colData names(5): cell_count ground_truth sample_id pxl_col_in_fullres ## pxl_row_in_fullres ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialData names(6) : barcode_id in_tissue ... x y ## spatialCoords names(2) : x y ## imgData names(4): sample_id image_id data scaleFactor # number of features (rows) and spots (columns) dim(spe) ## [1] 33538 4992 # names of &#39;assay&#39; tables assayNames(spe) ## [1] &quot;counts&quot; # features metadata head(rowData(spe)) ## DataFrame with 6 rows and 3 columns ## gene_id gene_name feature_type ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000243485 ENSG00000243485 MIR1302-2HG Gene Expression ## ENSG00000237613 ENSG00000237613 FAM138A Gene Expression ## ENSG00000186092 ENSG00000186092 OR4F5 Gene Expression ## ENSG00000238009 ENSG00000238009 AL627309.1 Gene Expression ## ENSG00000239945 ENSG00000239945 AL627309.3 Gene Expression ## ENSG00000239906 ENSG00000239906 AL627309.2 Gene Expression # spots metadata head(colData(spe)) ## DataFrame with 6 rows and 11 columns ## cell_count ground_truth sample_id pxl_col_in_fullres ## &lt;integer&gt; &lt;factor&gt; &lt;character&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 NA NA sample_151673 2435 ## AAACAAGTATCTCCCA-1 6 Layer3 sample_151673 8468 ## AAACAATCTACTAGCA-1 16 Layer1 sample_151673 2807 ## AAACACCAATAACTGC-1 5 WM sample_151673 9505 ## AAACAGAGCGACTCCT-1 2 Layer3 sample_151673 4151 ## AAACAGCTTTCAGAAG-1 4 Layer5 sample_151673 7583 ## pxl_row_in_fullres barcode_id in_tissue array_col ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 3913 AAACAACGAATAGTTC-1 0 0 ## AAACAAGTATCTCCCA-1 9791 AAACAAGTATCTCCCA-1 1 50 ## AAACAATCTACTAGCA-1 5769 AAACAATCTACTAGCA-1 1 3 ## AAACACCAATAACTGC-1 4068 AAACACCAATAACTGC-1 1 59 ## AAACAGAGCGACTCCT-1 9271 AAACAGAGCGACTCCT-1 1 14 ## AAACAGCTTTCAGAAG-1 3393 AAACAGCTTTCAGAAG-1 1 43 ## array_row x y ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 16 2435 3913 ## AAACAAGTATCTCCCA-1 102 8468 9791 ## AAACAATCTACTAGCA-1 43 2807 5769 ## AAACACCAATAACTGC-1 19 9505 4068 ## AAACAGAGCGACTCCT-1 94 4151 9271 ## AAACAGCTTTCAGAAG-1 9 7583 3393 # spatial metadata head(spatialData(spe)) ## DataFrame with 6 rows and 6 columns ## barcode_id in_tissue array_col array_row x ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 AAACAACGAATAGTTC-1 0 0 16 2435 ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 1 50 102 8468 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 1 3 43 2807 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 1 59 19 9505 ## AAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 1 14 94 4151 ## AAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 1 43 9 7583 ## y ## &lt;integer&gt; ## AAACAACGAATAGTTC-1 3913 ## AAACAAGTATCTCCCA-1 9791 ## AAACAATCTACTAGCA-1 5769 ## AAACACCAATAACTGC-1 4068 ## AAACAGAGCGACTCCT-1 9271 ## AAACAGCTTTCAGAAG-1 3393 # spatial coordinates head(spatialCoords(spe)) ## x y ## AAACAACGAATAGTTC-1 2435 3913 ## AAACAAGTATCTCCCA-1 8468 9791 ## AAACAATCTACTAGCA-1 2807 5769 ## AAACACCAATAACTGC-1 9505 4068 ## AAACAGAGCGACTCCT-1 4151 9271 ## AAACAGCTTTCAGAAG-1 7583 3393 # image metadata imgData(spe) ## DataFrame with 2 rows and 4 columns ## sample_id image_id data scaleFactor ## &lt;character&gt; &lt;character&gt; &lt;list&gt; &lt;numeric&gt; ## 1 sample_151673 lowres #### 0.0450045 ## 2 sample_151673 hires #### 0.1500150 References "],["quality-control.html", "Chapter 9 Quality control 9.1 Background 9.2 Load data 9.3 Plot data 9.4 Calculate QC metrics 9.5 Selecting thresholds 9.6 Zero-cell and single-cell spots 9.7 Quality control at gene level", " Chapter 9 Quality control 9.1 Background Quality control (QC) procedures at the spot level aim to remove low-quality spots before further analysis. Low-quality spots can occur due to problems during library preparation or other experimental procedures. Examples include large proportions of dead cells due to cell damage during library preparation, and low mRNA capture efficiency due to inefficient reverse transcription or PCR amplification. These spots are usually removed prior to further analysis, since otherwise they tend to create problems during downstream analyses such as clustering. For example, problematic spots that are not removed could show up as separate clusters, which may be misidentified as distinct cell types. Low-quality spots can be identified according to several characteristics, including: library size (i.e. total UMI counts per spot) number of expressed features (i.e. number of genes with non-zero UMI counts per spot) proportion of reads mapping to mitochondrial genes (a high proportion indicates cell damage) number of cells per spot (unusually high values can indicate problems) Low library size or low number of expressed features can indicate poor mRNA capture rates, e.g. due to cell damage and missing mRNAs, or low reaction efficiency. A high proportion of mitochondrial reads indicates cell damage, e.g. partial cell lysis leading to leakage and missing cytoplasmic mRNAs, with the resulting reads therefore concentrated on the remaining mitochondrial mRNAs that are relatively protected inside the mitochondrial membrane. Unusually high numbers of cells per spot can indicate problems during cell segmentation. The first three characteristics listed above are also used for QC in scRNA-seq data. However, the expected distributions for high-quality spots are different (compared to high-quality cells in scRNA-seq), since spots may contain zero, one, or multiple cells. 9.2 Load data library(SpatialExperiment) library(STexampleData) # load object spe &lt;- Visium_humanDLPFC() 9.3 Plot data As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected. We use visualization functions from the ggspavis package to generate plots. library(ggspavis) # plot spatial coordinates (spots) plotSpots(spe) 9.4 Calculate QC metrics We calculate the QC metrics described above with a combination of methods from the scater (McCarthy et al. 2017) package (for metrics that are also used for scRNA-seq data, where we treat spots as equivalent to cells) and our own functions. The QC metrics from scater can be calculated and added to the SpatialExperiment object as follows. Here, we also identify mitochondrial reads using their gene names, and pass these as an argument to scater. First, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we are not interested in. library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] dim(spe) ## [1] 33538 3639 # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) table(is_mito) ## is_mito ## FALSE TRUE ## 33525 13 rowData(spe)$gene_name[is_mito] ## [1] &quot;MT-ND1&quot; &quot;MT-ND2&quot; &quot;MT-CO1&quot; &quot;MT-CO2&quot; &quot;MT-ATP8&quot; &quot;MT-ATP6&quot; &quot;MT-CO3&quot; ## [8] &quot;MT-ND3&quot; &quot;MT-ND4L&quot; &quot;MT-ND4&quot; &quot;MT-ND5&quot; &quot;MT-ND6&quot; &quot;MT-CYB&quot; # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) head(colData(spe)) ## DataFrame with 6 rows and 23 columns ## cell_count ground_truth sample_id pxl_col_in_fullres ## &lt;integer&gt; &lt;factor&gt; &lt;character&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 6 Layer3 sample_151673 8468 ## AAACAATCTACTAGCA-1 16 Layer1 sample_151673 2807 ## AAACACCAATAACTGC-1 5 WM sample_151673 9505 ## AAACAGAGCGACTCCT-1 2 Layer3 sample_151673 4151 ## AAACAGCTTTCAGAAG-1 4 Layer5 sample_151673 7583 ## AAACAGGGTCTATATT-1 6 Layer6 sample_151673 8064 ## pxl_row_in_fullres barcode_id in_tissue array_col ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 9791 AAACAAGTATCTCCCA-1 1 50 ## AAACAATCTACTAGCA-1 5769 AAACAATCTACTAGCA-1 1 3 ## AAACACCAATAACTGC-1 4068 AAACACCAATAACTGC-1 1 59 ## AAACAGAGCGACTCCT-1 9271 AAACAGAGCGACTCCT-1 1 14 ## AAACAGCTTTCAGAAG-1 3393 AAACAGCTTTCAGAAG-1 1 43 ## AAACAGGGTCTATATT-1 3665 AAACAGGGTCTATATT-1 1 47 ## array_row x y sum detected ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 102 8468 9791 8458 3586 ## AAACAATCTACTAGCA-1 43 2807 5769 1667 1150 ## AAACACCAATAACTGC-1 19 9505 4068 3769 1960 ## AAACAGAGCGACTCCT-1 94 4151 9271 5433 2424 ## AAACAGCTTTCAGAAG-1 9 7583 3393 4278 2264 ## AAACAGGGTCTATATT-1 13 8064 3665 4004 2178 ## subsets_mito_sum subsets_mito_detected subsets_mito_percent ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 1407 13 16.6351 ## AAACAATCTACTAGCA-1 204 11 12.2376 ## AAACACCAATAACTGC-1 430 13 11.4089 ## AAACAGAGCGACTCCT-1 1316 13 24.2223 ## AAACAGCTTTCAGAAG-1 651 12 15.2174 ## AAACAGGGTCTATATT-1 621 13 15.5095 ## total barcode_id in_tissue array_col array_row ## &lt;numeric&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 8458 AAACAAGTATCTCCCA-1 1 50 102 ## AAACAATCTACTAGCA-1 1667 AAACAATCTACTAGCA-1 1 3 43 ## AAACACCAATAACTGC-1 3769 AAACACCAATAACTGC-1 1 59 19 ## AAACAGAGCGACTCCT-1 5433 AAACAGAGCGACTCCT-1 1 14 94 ## AAACAGCTTTCAGAAG-1 4278 AAACAGCTTTCAGAAG-1 1 43 9 ## AAACAGGGTCTATATT-1 4004 AAACAGGGTCTATATT-1 1 47 13 ## x y ## &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 8468 9791 ## AAACAATCTACTAGCA-1 2807 5769 ## AAACACCAATAACTGC-1 9505 4068 ## AAACAGAGCGACTCCT-1 4151 9271 ## AAACAGCTTTCAGAAG-1 7583 3393 ## AAACAGGGTCTATATT-1 8064 3665 9.5 Selecting thresholds The simplest option to apply the QC metrics is to select thresholds for each metric, and remove any spots that do not meet the thresholds for one or more metrics. Exploratory visualizations can be used to help select appropriate thresholds, which may differ depending on the dataset. Here, we use visualizations to select thresholds for several QC metrics in our human DLPFC dataset: (i) library size, (ii) number of expressed genes, (iii) proportion of mitochondrial reads, and (iv) number of cells per spot. 9.5.1 Library size Library size represents the total sum of UMI counts per spot. This is included in the column labeled sum in the scater output. Plot a histogram of the library sizes across spots. # histogram of library sizes hist(colData(spe)$sum, breaks = 20) The distribution is relatively smooth, and there are no obvious issue such as a spike at very low library sizes. We also plot the library sizes against the number of cells per spot (which is available for this dataset). This is to check that we are not inadvertently removing a biologically meaningful group of spots. The horizontal line (argument threshold) shows our first guess at a possible filtering threshold for library size based on the histogram. # plot library size vs. number of cells per spot plotQC(spe, type = &quot;scatter&quot;, metric_x = &quot;cell_count&quot;, metric_y = &quot;sum&quot;, threshold_y = 500) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. The plot shows that setting a filtering threshold for library size (e.g. at the value shown) does not appear to select for any obvious biologically consistent group of spots. We set a relatively arbitrary threshold of 500 UMI counts per spot, and then check the number of spots below this threshold. # select QC threshold for library size qc_lib_size &lt;- colData(spe)$sum &lt; 500 table(qc_lib_size) ## qc_lib_size ## FALSE TRUE ## 3632 7 colData(spe)$qc_lib_size &lt;- qc_lib_size Finally, we also check that the discarded spots do not have any obvious spatial pattern that correlates with known biological features. Otherwise, removing these spots could indicate that we have set the threshold too high, and are removing biologically informative spots. # check spatial pattern of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_lib_size&quot;) As an aside, here we can also illustrate what happens if we set the threshold too high. For example, if we set the threshold to 2000 UMI counts per spot – which may also seem like a reasonable value based on the histogram and scatterplot – then we see a possible spatial pattern in the discarded spots, matching the cortical layers. This illustrates the importance of interactively checking exploratory visualizations when choosing these thresholds. # check spatial pattern of discarded spots if threshold is too high qc_lib_size_2000 &lt;- colData(spe)$sum &lt; 2000 colData(spe)$qc_lib_size_2000 &lt;- qc_lib_size_2000 plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_lib_size_2000&quot;) For reference, here are the ground truth (manually annotated) cortical layers in this dataset. # plot ground truth (manually annotated) layers plotSpots(spe, annotate = &quot;ground_truth&quot;, palette = &quot;libd_layer_colors&quot;) ## Warning: Removed 28 rows containing missing values (geom_point). 9.5.2 Number of expressed features The number of expressed features refers to the number of genes with non-zero UMI counts per spot. This is stored in the column detected in the scater output. We use a similar sequence of visualizations to choose a threshold for this QC metric. # histogram of numbers of expressed genes hist(colData(spe)$detected, breaks = 20) # plot number of expressed genes vs. number of cells per spot plotQC(spe, type = &quot;scatter&quot;, metric_x = &quot;cell_count&quot;, metric_y = &quot;detected&quot;, threshold_y = 250) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Based on the plots, we select a threshold of 250 expressed genes per spot. # select QC threshold for number of expressed genes qc_detected &lt;- colData(spe)$detected &lt; 250 table(qc_detected) ## qc_detected ## FALSE TRUE ## 3634 5 colData(spe)$qc_detected &lt;- qc_detected # check spatial pattern of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_detected&quot;) Again, we also check what happens when we set the threshold too high. # check spatial pattern of discarded spots if threshold is too high qc_detected_1000 &lt;- colData(spe)$detected &lt; 1000 colData(spe)$qc_detected_1000 &lt;- qc_detected_1000 plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_detected_1000&quot;) 9.5.3 Proportion of mitochondrial reads A high proportion of mitochondrial reads indicates cell damage. We investigate the proportions of mitochondrial reads across spots, and select an appropriate threshold. The proportions of mitochondrial reads per spot are stored in the column subsets_mito_percent in the scater output. # histogram of mitochondrial read proportions hist(colData(spe)$subsets_mito_percent, breaks = 20) # plot mitochondrial read proportion vs. number of cells per spot plotQC(spe, type = &quot;scatter&quot;, metric_x = &quot;cell_count&quot;, metric_y = &quot;subsets_mito_percent&quot;, threshold_y = 30) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. We select a threshold of 30% for the mitochondrial read proportion. # select QC threshold for mitochondrial read proportion qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 table(qc_mito) ## qc_mito ## FALSE TRUE ## 3636 3 colData(spe)$qc_mito &lt;- qc_mito # check spatial pattern of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_mito&quot;) We also check what happens when we set the threshold too low. # check spatial pattern of discarded spots if threshold is too high qc_mito_25 &lt;- colData(spe)$subsets_mito_percent &gt; 25 colData(spe)$qc_mito_25 &lt;- qc_mito_25 plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_mito_25&quot;) 9.5.4 Number of cells per spot The number of cells per spot depends on the tissue type and organism. Here, we check for any outlier values that could indicate problems during cell segmentation. # histogram of cell counts hist(colData(spe)$cell_count, breaks = 20) # distribution of cells per spot tbl_cells_per_spot &lt;- table(colData(spe)$cell_count) We see a tail of very high values, which could indicate problems for these spots. These values are also visible on the scatterplots. Here, we again plot the number of expressed genes vs. cell count, with an added trend. # plot number of expressed genes vs. number of cells per spot plotQC(spe, type = &quot;scatter&quot;, metric_x = &quot;cell_count&quot;, metric_y = &quot;detected&quot;, threshold_x = 12) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. In particular, we see that the spots with very high cell counts also have low numbers of expressed genes. This indicates that the experiments have failed for these spots, and they should be removed. We select a threshold of 12 cells per spot. The number of spots above this threshold is relatively small, and there is a clear downward trend in the number of expressed genes above this threshold. # select QC threshold for number of cells per spot qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 table(qc_cell_count) ## qc_cell_count ## FALSE TRUE ## 3592 47 colData(spe)$qc_cell_count &lt;- qc_cell_count # check spatial pattern of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;qc_cell_count&quot;) While there is a spatial pattern to the discarded spots, it does not appear to be correlated with the known biological features (cortical layers). The discarded spots are all on the edges of the tissue. It seems plausible that something has gone wrong with the cell segmentation on the edges of the images, so it makes sense to remove these spots. 9.5.5 Remove low-quality spots Now that we have calculated several QC metrics and selected thresholds for each one, we can combine the sets of low-quality spots, and remove them from our object. We also check again that the combined set of discarded spots does not correspond to any obvious biologically relevant group of spots. # number of discarded spots for each metric apply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum) ## qc_lib_size qc_detected qc_mito qc_cell_count ## 7 5 3 47 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count table(discard) ## discard ## FALSE TRUE ## 3582 57 # store in object colData(spe)$discard &lt;- discard # check spatial pattern of combined set of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;discard&quot;) # remove combined set of low-quality spots spe &lt;- spe[, !colData(spe)$discard] dim(spe) ## [1] 33538 3582 9.6 Zero-cell and single-cell spots A particular characteristic of Visium data is that spots can contain zero, one, or multiple cells. We could also imagine other filtering procedures such as (i) removing spots with zero cells, or (ii) restricting the analysis to spots containing a single cell (which would make the data more similar to scRNA-seq). However, this would discard a large amount of information. Below, we show the distribution of cells per spot again (up to the filtering threshold of 12 cells per spot from above). # distribution of cells per spot tbl_cells_per_spot[1:13] ## ## 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 84 211 483 623 617 541 421 287 140 92 50 25 18 # as proportions prop_cells_per_spot &lt;- round(tbl_cells_per_spot / sum(tbl_cells_per_spot), 2) prop_cells_per_spot[1:13] ## ## 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 0.02 0.06 0.13 0.17 0.17 0.15 0.12 0.08 0.04 0.03 0.01 0.01 0.00 Only 6% of spots contain a single cell. If we restricted the analysis to these spots only, we would be discarding most of the data. Removing the spots containing zero cells (2% of spots) would also be problematic, since these spots can also contain biologically meaningful information. For example, in this brain dataset, the regions between cell bodies consists of neuropil (dense networks of axons and dendrites). In our paper (Maynard et al. 2021), we explore the information contained in these neuropil spots. 9.7 Quality control at gene level The sections above consider quality control at the spot level. In some datasets, it may also be appropriate to apply quality control procedures or filtering at the gene level. For example, certain genes may be biologically irrelevant for downstream analyses. However, here we make a distinction between quality control and feature selection. Removing biologically uninteresting genes (such as mitochondrial genes) may also be considered as part of feature selection, since there is no underlying experimental procedure that has failed. Therefore, we will discuss gene-level filtering in the Feature selection chapter. References "],["normalization.html", "Chapter 10 Normalization 10.1 Background 10.2 Previous steps 10.3 Log-transformed normalized counts", " Chapter 10 Normalization 10.1 Background Here we apply normalization methods developed for scRNA-seq data, treating each spot as equivalent to one cell. 10.2 Previous steps Code to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter. # LOAD DATA library(SpatialExperiment) library(STexampleData) spe &lt;- Visium_humanDLPFC() # QUALITY CONTROL (QC) library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] 10.3 Log-transformed normalized counts Calculate log-transformed normalized counts (abbreviated as “logcounts”), using pool-based size factors and deconvolution to the spot level. We use normalization methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016), which were originally developed for single-cell RNA sequencing data. We make the assumption that these methods can be applied here by treating spots as equivalent to cells. Since we have only a single sample, there are no blocking factors in the experimental design. library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) table(qclus) ## qclus ## 1 2 3 4 5 6 7 8 9 10 ## 372 245 254 744 415 230 394 299 492 137 # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) summary(sizeFactors(spe)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1334 0.6093 0.8844 1.0000 1.2852 4.2475 hist(sizeFactors(spe), breaks = 20) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) # check assayNames(spe) ## [1] &quot;counts&quot; &quot;logcounts&quot; dim(counts(spe)) ## [1] 33538 3582 dim(logcounts(spe)) ## [1] 33538 3582 References "],["feature-selection.html", "Chapter 11 Feature selection 11.1 Background 11.2 Previous steps 11.3 Highly variable genes (HVGs) 11.4 Spatially variable genes (SVGs)", " Chapter 11 Feature selection 11.1 Background Here we apply feature selection methods to identify highly variable genes (HVGs) for further downstream analyses. 11.2 Previous steps Code to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter. # LOAD DATA library(SpatialExperiment) library(STexampleData) spe &lt;- Visium_humanDLPFC() # QUALITY CONTROL (QC) library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # NORMALIZATION library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) spe &lt;- logNormCounts(spe) 11.3 Highly variable genes (HVGs) We use methods from scran (Lun, McCarthy, and Marioni 2016) to identify a set of top highly variable genes (HVGs), which will be used to define cell types. These methods were originally developed for single-cell RNA sequencing, so here we assume that spots can be treated as equivalent to cells, and we use only molecular features (gene expression). First, we remove mitochondrial genes, since these are very highly expressed in this dataset, and are not of biological interest. # remove mitochondrial genes spe &lt;- spe[!is_mito, ] dim(spe) ## [1] 33525 3582 Then, apply methods from scran. This gives us a list of HVGs, which can be used for further downstream analyses. library(scran) # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # visualize mean-variance relationship fit &lt;- metadata(dec) plot(fit$mean, fit$var, xlab = &quot;mean of log-expression&quot;, ylab = &quot;variance of log-expression&quot;) curve(fit$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) length(top_hvgs) ## [1] 1448 11.4 Spatially variable genes (SVGs) To do: add section on alternative methods for identifying SVGs References "],["dimensionality-reduction.html", "Chapter 12 Dimensionality reduction 12.1 Background 12.2 Previous steps 12.3 Principal component analysis (PCA) 12.4 Uniform Manifold Approximation and Projection (UMAP) 12.5 Visualizations", " Chapter 12 Dimensionality reduction 12.1 Background In this chapter, we apply dimensionality reduction methods to visualize the data and to generate inputs for further downstream analyses. 12.2 Previous steps Code to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter. # LOAD DATA library(SpatialExperiment) library(STexampleData) spe &lt;- Visium_humanDLPFC() # QUALITY CONTROL (QC) library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # NORMALIZATION library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) spe &lt;- logNormCounts(spe) # FEATURE SELECTION # remove mitochondrial genes spe &lt;- spe[!is_mito, ] # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) 12.3 Principal component analysis (PCA) Apply principal component analysis (PCA) to the set of top highly variable genes (HVGs) to reduce the dimensionality of the dataset, and retain the top 50 principal components (PCs) for further downstream analyses. This is done for two reasons: (i) to reduce noise due to random variation in expression of biologically uninteresting genes, which are assumed to have expression patterns that are independent of each other, and (ii) to improve computational efficiency during downstream analyses. We use the computationally efficient implementation of PCA provided in the scater package (McCarthy et al. 2017). This implementation uses randomization, and therefore requires setting a random seed for reproducibility. # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) reducedDimNames(spe) ## [1] &quot;PCA&quot; dim(reducedDim(spe, &quot;PCA&quot;)) ## [1] 3582 50 12.4 Uniform Manifold Approximation and Projection (UMAP) We also run UMAP (McInnes, Healy, and Melville 2018) on the set of top 50 PCs and retain the top 2 UMAP components, which will be used for visualization purposes. # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) reducedDimNames(spe) ## [1] &quot;PCA&quot; &quot;UMAP&quot; dim(reducedDim(spe, &quot;UMAP&quot;)) ## [1] 3582 2 # update column names for easier plotting colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 12.5 Visualizations Generate plots using plotting functions from the ggspavis package. In the next chapter on clustering, we will add cluster labels to these reduced dimension plots. library(ggspavis) # plot top 2 PCA dimensions plotDimRed(spe, type = &quot;PCA&quot;) # plot top 2 UMAP dimensions plotDimRed(spe, type = &quot;UMAP&quot;) References "],["clustering.html", "Chapter 13 Clustering 13.1 Overview 13.2 Previous steps 13.3 Clustering on HVGs 13.4 Clustering on HVGs and spatial dimensions 13.5 BayesSpace", " Chapter 13 Clustering 13.1 Overview Clustering is used in single-cell and spatial analysis to identify cell types. Cell types and subtypes can be defined at various resolutions, depending on biological context. For the purposes of clustering, this means that the desired number of clusters also depends on biological context. In the spatial context, we may be interested in e.g. (i) identifying cell types or subtypes that occur in biologically interesting spatial patterns, or (ii) identifying major cell types and performing subsequent analyses within these cell types. 13.2 Previous steps Code to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter. # LOAD DATA library(SpatialExperiment) library(STexampleData) spe &lt;- Visium_humanDLPFC() # QUALITY CONTROL (QC) library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # NORMALIZATION library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) spe &lt;- logNormCounts(spe) # FEATURE SELECTION # remove mitochondrial genes spe &lt;- spe[!is_mito, ] # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) # DIMENSIONALITY REDUCTION # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) # update column names colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 13.3 Clustering on HVGs We can perform clustering by applying standard clustering methods developed for single-cell RNA sequencing data, using molecular features (gene expression). Here, we apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs. In the context of spatial data, this means we assume that biologically informative spatial distribution patterns of cell types can be detected from the molecular features (gene expression). # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership table(clus) ## clus ## 1 2 3 4 5 6 ## 372 916 342 1083 349 520 # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) Visualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) reduced dimension space (PCA or UMAP). We use plotting functions from the ggspavis package. For reference, we also display the ground truth (manually annotated) labels available for this dataset (in spatial coordinates). From the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly. library(ggspavis) # plot clusters in spatial x-y coordinates plotSpots(spe, annotate = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) # plot ground truth labels in spatial coordinates plotSpots(spe, annotate = &quot;ground_truth&quot;, palette = &quot;libd_layer_colors&quot;) ## Warning: Removed 14 rows containing missing values (geom_point). # plot clusters in PCA reduced dimensions plotDimRed(spe, type = &quot;PCA&quot;, annotate = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) # plot clusters in UMAP reduced dimensions plotDimRed(spe, type = &quot;UMAP&quot;, annotate = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) 13.4 Clustering on HVGs and spatial dimensions To do: describe approach from our publication Maynard et al. (2021) to combine molecular and spatial features with appropriate scaling. 13.5 BayesSpace To do: section on BayesSpace (Zhao et al. 2020) References "],["marker-genes.html", "Chapter 14 Marker genes 14.1 Background 14.2 Previous steps 14.3 Marker genes", " Chapter 14 Marker genes 14.1 Background In this chapter, we identify marker genes for each cluster by testing for differential expression between clusters. 14.2 Previous steps Code to run steps from the previous chapters to generate the SpatialExperiment object required for this chapter. # LOAD DATA library(SpatialExperiment) library(STexampleData) spe &lt;- Visium_humanDLPFC() # QUALITY CONTROL (QC) library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # NORMALIZATION library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) spe &lt;- logNormCounts(spe) # FEATURE SELECTION # remove mitochondrial genes spe &lt;- spe[!is_mito, ] # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) # DIMENSIONALITY REDUCTION # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) # update column names colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) # CLUSTERING # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership colLabels(spe) &lt;- factor(clus) 14.3 Marker genes Identify marker genes by testing for differential gene expression between clusters. We use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs. not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally. library(scran) library(scater) library(pheatmap) # set gene names as row names for easier plotting rownames(spe) &lt;- rowData(spe)$gene_name # test for marker genes markers &lt;- findMarkers(spe, test = &quot;binom&quot;, direction = &quot;up&quot;) # returns a list with one DataFrame per cluster markers ## List of length 6 ## names(6): 1 2 3 4 5 6 # plot log-fold changes for one cluster over all other clusters # selecting cluster 1 interesting &lt;- markers[[1]] best_set &lt;- interesting[interesting$Top &lt;= 5, ] logFCs &lt;- getMarkerEffects(best_set) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) # plot log-transformed normalized expression of top genes for one cluster top_genes &lt;- head(rownames(interesting)) plotExpression(spe, x = &quot;label&quot;, features = top_genes) References "],["workflows.html", "Chapter 15 Workflows", " Chapter 15 Workflows The chapters in this part each contain a complete workflow for one dataset. This shows how the individual analysis steps described in the previous part fit together. The workflows have been selected to cover different tissue types and platforms. For more details on the individual analysis steps, see the previous chapters. "],["visium-human-dlpfc-workflow.html", "Chapter 16 Visium human DLPFC workflow 16.1 Description of dataset 16.2 Load data 16.3 Plot data 16.4 Quality control (QC) 16.5 Normalization 16.6 Feature selection 16.7 Dimensionality reduction 16.8 Clustering 16.9 Marker genes", " Chapter 16 Visium human DLPFC workflow This workflow analyzes one sample of human brain from the dorsolateral prefrontal cortex (DLPFC) region, measured using the 10x Genomics Visium platform. This is a condensed version of the analyses shown in the individual analysis chapters in the previous part. For more details on the individual steps, see the previous chapters. 16.1 Description of dataset This is a 10x Genomics Visium dataset generated from healthy human brain samples from the dorsolateral prefrontal cortex (DLPFC) region. In the full dataset, there are 12 samples in total, from 3 individuals, with 2 pairs of “spatially adjacent” replicates (serial sections) per individual (4 samples per individual). The individuals and spatially adjacent replicates can be considered as blocking factors. Each sample spans the six layers of the cortex plus white matter in a perpendicular tissue section. For the examples in this workflow and the analysis chapters, we use a single sample from this dataset (sample 151673), mainly to reduce computational requirements to compile the book. This dataset is described in our publication Maynard et al. (2021). The full dataset is publicly available through the spatialLIBD Bioconductor package, and the analysis code from our paper is provided in the HumanPilot GitHub repository. The dataset can also be explored interactively through the spatialLIBD Shiny web app. 16.2 Load data Here, we load a single sample from this dataset (sample 151673), which is available as a SpatialExperiment object from the STexampleData package. library(SpatialExperiment) library(STexampleData) # load object spe &lt;- Visium_humanDLPFC() spe ## class: SpatialExperiment ## dim: 33538 4992 ## metadata(0): ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): gene_id gene_name feature_type ## colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... ## TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 ## colData names(5): cell_count ground_truth sample_id pxl_col_in_fullres ## pxl_row_in_fullres ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialData names(6) : barcode_id in_tissue ... x y ## spatialCoords names(2) : x y ## imgData names(4): sample_id image_id data scaleFactor 16.3 Plot data As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected. We use visualization functions from the ggspavis package to generate plots. library(ggspavis) # plot spatial coordinates (spots) plotSpots(spe) 16.4 Quality control (QC) First, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we are not interested in. # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] dim(spe) ## [1] 33538 3639 Next, calculate spot-level QC metrics using the scater package (McCarthy et al. 2017), and store the QC metrics in colData. See Quality control for more details, including explanations of the QC metrics. library(scater) # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) table(is_mito) ## is_mito ## FALSE TRUE ## 33525 13 rowData(spe)$gene_name[is_mito] ## [1] &quot;MT-ND1&quot; &quot;MT-ND2&quot; &quot;MT-CO1&quot; &quot;MT-CO2&quot; &quot;MT-ATP8&quot; &quot;MT-ATP6&quot; &quot;MT-CO3&quot; ## [8] &quot;MT-ND3&quot; &quot;MT-ND4L&quot; &quot;MT-ND4&quot; &quot;MT-ND5&quot; &quot;MT-ND6&quot; &quot;MT-CYB&quot; # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) head(colData(spe), 3) ## DataFrame with 3 rows and 23 columns ## cell_count ground_truth sample_id pxl_col_in_fullres ## &lt;integer&gt; &lt;factor&gt; &lt;character&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 6 Layer3 sample_151673 8468 ## AAACAATCTACTAGCA-1 16 Layer1 sample_151673 2807 ## AAACACCAATAACTGC-1 5 WM sample_151673 9505 ## pxl_row_in_fullres barcode_id in_tissue array_col ## &lt;integer&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 9791 AAACAAGTATCTCCCA-1 1 50 ## AAACAATCTACTAGCA-1 5769 AAACAATCTACTAGCA-1 1 3 ## AAACACCAATAACTGC-1 4068 AAACACCAATAACTGC-1 1 59 ## array_row x y sum detected ## &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 102 8468 9791 8458 3586 ## AAACAATCTACTAGCA-1 43 2807 5769 1667 1150 ## AAACACCAATAACTGC-1 19 9505 4068 3769 1960 ## subsets_mito_sum subsets_mito_detected subsets_mito_percent ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 1407 13 16.6351 ## AAACAATCTACTAGCA-1 204 11 12.2376 ## AAACACCAATAACTGC-1 430 13 11.4089 ## total barcode_id in_tissue array_col array_row ## &lt;numeric&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 8458 AAACAAGTATCTCCCA-1 1 50 102 ## AAACAATCTACTAGCA-1 1667 AAACAATCTACTAGCA-1 1 3 43 ## AAACACCAATAACTGC-1 3769 AAACACCAATAACTGC-1 1 59 19 ## x y ## &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 8468 9791 ## AAACAATCTACTAGCA-1 2807 5769 ## AAACACCAATAACTGC-1 9505 4068 Select filtering thresholds for the QC metrics by examining distributions using histograms. For additional details, including further exploratory visualizations to select the thresholds, see Quality control. Here, we use relatively relaxed thresholds, since the additional exploratory visualizations showed that more stringent thresholds tended to remove groups of spots corresponding to biologically meaningful regions. # histograms of QC metrics par(mfrow = c(1, 4)) hist(colData(spe)$sum, xlab = &quot;sum&quot;, main = &quot;UMIs per spot&quot;) hist(colData(spe)$detected, xlab = &quot;detected&quot;, main = &quot;Genes per spot&quot;) hist(colData(spe)$subsets_mito_percent, xlab = &quot;percent mitochondrial&quot;, main = &quot;Percent mito UMIs&quot;) hist(colData(spe)$cell_count, xlab = &quot;number of cells&quot;, main = &quot;No. cells per spot&quot;) par(mfrow = c(1, 1)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # number of discarded spots for each metric apply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum) ## qc_lib_size qc_detected qc_mito qc_cell_count ## 7 5 3 47 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count table(discard) ## discard ## FALSE TRUE ## 3582 57 # store in object colData(spe)$discard &lt;- discard Plot the set of discarded spots in the spatial x-y coordinates, to confirm that the spatial distribution of the discarded spots does not correspond to any biologically meaningful regions, which would indicate that we are removing biologically informative spots. # check spatial pattern of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;discard&quot;) There is some concentration of discarded spots at the edge of the tissue region, which may be due to tissue damage. Importantly, the discarded spots do not correspond to any of the cortical layers of interest. We filter out the low-quality spots from the object. # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] dim(spe) ## [1] 33538 3582 16.5 Normalization Calculate log-transformed normalized counts, using pool-based size factors and deconvolution to the spot level. We use normalization methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016), by assuming that these methods can be applied by treating spots as equivalent to cells. Since we have a single sample, there are no blocking factors. For more details, see Normalization. library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) table(qclus) ## qclus ## 1 2 3 4 5 6 7 8 9 10 ## 372 245 254 744 415 230 394 299 492 137 # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) summary(sizeFactors(spe)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1334 0.6093 0.8844 1.0000 1.2852 4.2475 hist(sizeFactors(spe), breaks = 20) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) assayNames(spe) ## [1] &quot;counts&quot; &quot;logcounts&quot; 16.6 Feature selection Identify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from scran (Lun, McCarthy, and Marioni 2016), treating spots as equivalent to cells, and considering only molecular features (gene expression), as described in Feature selection. We also first filter out mitochondrial genes, since these are very highly expressed and not of biological interest here. # remove mitochondrial genes spe &lt;- spe[!is_mito, ] dim(spe) ## [1] 33525 3582 # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # visualize mean-variance relationship fit &lt;- metadata(dec) plot(fit$mean, fit$var, xlab = &quot;mean of log-expression&quot;, ylab = &quot;variance of log-expression&quot;) curve(fit$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) length(top_hvgs) ## [1] 1448 16.7 Dimensionality reduction Run principal component analysis (PCA) to the set of top HVGs, and retain the top 50 principal components (PCs) for further downstream analyses. This is done both to reduce noise and to improve computational efficiency. We also run UMAP on the set of top 50 PCs and retain the top 2 UMAP components for visualization purposes. We use the computationally efficient implementation of PCA available in scater (McCarthy et al. 2017), which uses randomization, and therefore requires setting a random seed for reproducibility. # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) reducedDimNames(spe) ## [1] &quot;PCA&quot; dim(reducedDim(spe, &quot;PCA&quot;)) ## [1] 3582 50 # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) reducedDimNames(spe) ## [1] &quot;PCA&quot; &quot;UMAP&quot; dim(reducedDim(spe, &quot;UMAP&quot;)) ## [1] 3582 2 # update column names for easier plotting colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 16.8 Clustering Next, we perform clustering to define cell types. Here, we use molecular features (gene expression) only, as described in Clustering. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs. # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership table(clus) ## clus ## 1 2 3 4 5 6 ## 372 916 342 1083 349 520 # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) Visualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) UMAP dimensions. From the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly. # plot clusters in spatial x-y coordinates plotSpots(spe, annotate = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) # plot ground truth labels in spatial coordinates plotSpots(spe, annotate = &quot;ground_truth&quot;, palette = &quot;libd_layer_colors&quot;) ## Warning: Removed 14 rows containing missing values (geom_point). # plot clusters in UMAP reduced dimensions plotDimRed(spe, type = &quot;UMAP&quot;, annotate = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) 16.9 Marker genes Identify marker genes by testing for differential gene expression between clusters. We use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs. not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally. # set gene names as row names for easier plotting rownames(spe) &lt;- rowData(spe)$gene_name # test for marker genes markers &lt;- findMarkers(spe, test = &quot;binom&quot;, direction = &quot;up&quot;) # returns a list with one DataFrame per cluster markers ## List of length 6 ## names(6): 1 2 3 4 5 6 library(pheatmap) # plot log-fold changes for one cluster over all other clusters # selecting cluster 1 interesting &lt;- markers[[1]] best_set &lt;- interesting[interesting$Top &lt;= 5, ] logFCs &lt;- getMarkerEffects(best_set) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) # plot log-transformed normalized expression of top genes for one cluster top_genes &lt;- head(rownames(interesting)) plotExpression(spe, x = &quot;label&quot;, features = top_genes) References "],["visium-mouse-coronal-workflow.html", "Chapter 17 Visium mouse coronal workflow 17.1 Description of dataset 17.2 Load data 17.3 Plot data 17.4 Quality control (QC) 17.5 Normalization 17.6 Feature selection 17.7 Dimensionality reduction 17.8 Clustering 17.9 Marker genes", " Chapter 17 Visium mouse coronal workflow This workflow analyzes a mouse coronal brain section dataset from the 10x Genomics Visium platform. This dataset was generated by 10x Genomics, and the raw data files are publicly available from the 10x Genomics website. 17.1 Description of dataset This dataset measures transcriptome-wide gene expression on a Visium slide spanning one hemisphere of a mouse coronal brain section. For experimental details, see the 10x Genomics website. Due to the small size of the mouse brain and the dimensions of the Visium slide (6.5mm x 6.5mm), the measurements span an entire brain hemisphere. Therefore, we can use this dataset to compare gene expression profiles between major anatomical regions of the mouse brain. Due to the small size of cells in the mouse brain, each spot can contain up to 50 cells. In this dataset, we do not know the exact number of cells per spot. 17.2 Load data The dataset is available in SpatialExperiment format from the STexampleData package. library(SpatialExperiment) library(STexampleData) # load object spe &lt;- Visium_mouseCoronal() spe ## class: SpatialExperiment ## dim: 32285 4992 ## metadata(0): ## assays(1): counts ## rownames(32285): ENSMUSG00000051951 ENSMUSG00000089699 ... ## ENSMUSG00000095019 ENSMUSG00000095041 ## rowData names(3): gene_id gene_name feature_type ## colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... ## TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 ## colData names(3): sample_id pxl_col_in_fullres pxl_row_in_fullres ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialData names(6) : barcode_id in_tissue ... x y ## spatialCoords names(2) : x y ## imgData names(4): sample_id image_id data scaleFactor 17.3 Plot data As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide. This confirms that the object has loaded correctly, and the orientation matches the 10x Genomics website. We use visualization functions from the ggspavis package to generate plots. library(ggspavis) # plot spatial coordinates (spots) plotSpots(spe) 17.4 Quality control (QC) Subset object to keep only spots over tissue. # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] dim(spe) ## [1] 32285 2702 Calculate spot-level QC metrics using the scater package (McCarthy et al. 2017), and store the QC metrics in colData. library(scater) # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) table(is_mito) ## is_mito ## FALSE TRUE ## 32272 13 rowData(spe)$gene_name[is_mito] ## [1] &quot;mt-Nd1&quot; &quot;mt-Nd2&quot; &quot;mt-Co1&quot; &quot;mt-Co2&quot; &quot;mt-Atp8&quot; &quot;mt-Atp6&quot; &quot;mt-Co3&quot; ## [8] &quot;mt-Nd3&quot; &quot;mt-Nd4l&quot; &quot;mt-Nd4&quot; &quot;mt-Nd5&quot; &quot;mt-Nd6&quot; &quot;mt-Cytb&quot; # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) head(colData(spe), 3) ## DataFrame with 3 rows and 21 columns ## sample_id pxl_col_in_fullres pxl_row_in_fullres ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 sample01 7237 8229 ## AAACAATCTACTAGCA-1 sample01 1611 4169 ## AAACACCAATAACTGC-1 sample01 8315 2518 ## barcode_id in_tissue array_col array_row x ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 1 50 102 7237 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 1 3 43 1611 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 1 59 19 8315 ## y sum detected subsets_mito_sum ## &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 8229 20935 5230 4036 ## AAACAATCTACTAGCA-1 4169 14789 3646 3419 ## AAACACCAATAACTGC-1 2518 34646 6272 5068 ## subsets_mito_detected subsets_mito_percent total ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 13 19.2787 20935 ## AAACAATCTACTAGCA-1 13 23.1185 14789 ## AAACACCAATAACTGC-1 13 14.6280 34646 ## barcode_id in_tissue array_col array_row x ## &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 1 50 102 7237 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 1 3 43 1611 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 1 59 19 8315 ## y ## &lt;integer&gt; ## AAACAAGTATCTCCCA-1 8229 ## AAACAATCTACTAGCA-1 4169 ## AAACACCAATAACTGC-1 2518 Select filtering thresholds for the QC metrics by examining distributions using histograms. # histograms of QC metrics par(mfrow = c(1, 3)) hist(colData(spe)$sum, xlab = &quot;sum&quot;, main = &quot;UMIs per spot&quot;) hist(colData(spe)$detected, xlab = &quot;detected&quot;, main = &quot;Genes per spot&quot;) hist(colData(spe)$subsets_mito_percent, xlab = &quot;percent mitochondrial&quot;, main = &quot;Percent mito UMIs&quot;) par(mfrow = c(1, 1)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 5000 qc_detected &lt;- colData(spe)$detected &lt; 1000 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 # number of discarded spots for each QC metric apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum) ## qc_lib_size qc_detected qc_mito ## 9 4 11 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito table(discard) ## discard ## FALSE TRUE ## 2683 19 # store in object colData(spe)$discard &lt;- discard Plot discarded spots in x-y coordinates on the tissue slide to check if there is any biologically meaningful spatial pattern. This would be problematic, since it would mean we are removing biologically informative spots. # check spatial pattern of discarded spots plotQC(spe, type = &quot;spots&quot;, discard = &quot;discard&quot;) There is one small region with some concentrated discarded spots at the top-left. However, this does not appear to correspond to any specific known anatomical region of interest. We assume that these are low-quality spots, and filtering them out will not cause problems in the biological interpretation. We filter out the low-quality spots from the object. # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] dim(spe) ## [1] 32285 2683 17.5 Normalization Next, we calculate log-transformed normalized counts, using pool-based size factors and deconvolution to the spot level, using methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016). Since we have a single sample, there are no blocking factors in the experimental design. library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) table(qclus) ## qclus ## 1 2 3 4 5 6 7 8 9 10 11 12 ## 178 162 255 450 274 235 320 250 105 119 131 204 # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) summary(sizeFactors(spe)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1009 0.6032 0.8985 1.0000 1.2649 6.0391 hist(log10(sizeFactors(spe)), xlab = &quot;log10 (size factors)&quot;, main = &quot;Size factors&quot;) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) assayNames(spe) ## [1] &quot;counts&quot; &quot;logcounts&quot; 17.6 Feature selection Identify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from scran (Lun, McCarthy, and Marioni 2016), and first filter out mitochondrial genes (since these are very highly expressed and not of biological interest here). # remove mitochondrial genes spe &lt;- spe[!is_mito, ] dim(spe) ## [1] 32272 2683 # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # visualize mean-variance relationship fit &lt;- metadata(dec) plot(fit$mean, fit$var, xlab = &quot;mean of log-expression&quot;, ylab = &quot;variance of log-expression&quot;) curve(fit$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) length(top_hvgs) ## [1] 1216 Note there are a few extremely highly expressed genes, which influence the fitted mean-variance relationship. We check the names of these genes to decide whether they should be removed as outliers. # identify outlier genes rev(sort(fit$mean))[1:3] ## ENSMUSG00000115783 ENSMUSG00000098178 ENSMUSG00000024661 ## 10.992042 9.904624 7.370274 outlier_ids &lt;- names(rev(sort(fit$mean))[1:3]) rowData(spe)[outlier_ids, ] ## DataFrame with 3 rows and 3 columns ## gene_id gene_name feature_type ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSMUSG00000115783 ENSMUSG00000115783 Bc1 Gene Expression ## ENSMUSG00000098178 ENSMUSG00000098178 Gm42418 Gene Expression ## ENSMUSG00000024661 ENSMUSG00000024661 Fth1 Gene Expression These appear to be biologically meaningful genes, so we leave them in. 17.7 Dimensionality reduction Run principal component analysis (PCA) using scater (McCarthy et al. 2017), and retain the top 50 principal components (PCs) for downstream analyses. Also run UMAP on the top 50 PCs, and retain the top 2 UMAP components for visualization purposes. # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) reducedDimNames(spe) ## [1] &quot;PCA&quot; dim(reducedDim(spe, &quot;PCA&quot;)) ## [1] 2683 50 # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) reducedDimNames(spe) ## [1] &quot;PCA&quot; &quot;UMAP&quot; dim(reducedDim(spe, &quot;UMAP&quot;)) ## [1] 2683 2 # update column names for easier plotting colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 17.8 Clustering Perform clustering to define cell types. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs. # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership table(clus) ## clus ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## 125 126 61 229 241 283 165 132 161 267 122 43 99 94 101 161 26 58 64 24 ## 21 22 23 ## 51 32 18 # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) Visualize the clusters by plotting in (i) spatial (x-y) coordinates on the tissue slide, and (ii) UMAP dimensions. # define custom color palette colors &lt;- unname(palette.colors(palette = &quot;Polychrome 36&quot;)) # plot clusters in spatial x-y coordinates plotSpots(spe, annotate = &quot;label&quot;, palette = colors) # plot clusters in UMAP dimensions plotDimRed(spe, type = &quot;UMAP&quot;, annotate = &quot;label&quot;, palette = colors) 17.9 Marker genes Identify marker genes by testing for differential gene expression between clusters, using the binomial test implemented in findMarkers in scran (Lun, McCarthy, and Marioni 2016). # set gene names as row names for easier plotting rownames(spe) &lt;- rowData(spe)$gene_name # test for marker genes markers &lt;- findMarkers(spe, test = &quot;binom&quot;, direction = &quot;up&quot;) # returns a list with one DataFrame per cluster markers ## List of length 23 ## names(23): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(pheatmap) # plot log-fold changes for one cluster over all other clusters # selecting cluster 5 interesting &lt;- markers[[5]] best_set &lt;- interesting[interesting$Top &lt;= 5, ] logFCs &lt;- getMarkerEffects(best_set) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) # plot log-transformed normalized expression of top genes for one cluster top_genes &lt;- head(rownames(interesting)) plotExpression(spe, x = &quot;label&quot;, features = top_genes) References "],["visium-spatiallibd-workflow.html", "Chapter 18 Visium spatialLIBD workflow", " Chapter 18 Visium spatialLIBD workflow Workflow using dataset loaded from spatialLIBD package, highlighting additional features not shown in Visium human DLPFC workflow chapter. "],["contributors.html", "Chapter 19 Contributors", " Chapter 19 Contributors Lukas M. Weber, Johns Hopkins Bloomberg School of Public Health, Baltimore, MD, USA Abby Spangler, Lieber Institute for Brain Development, Baltimore, MD, USA Leonardo Collado-Torres, Lieber Institute for Brain Development, Baltimore, MD, USA Stephanie C. Hicks, Johns Hopkins Bloomberg School of Public Health, Baltimore, MD, USA "],["references.html", "Chapter 20 References", " Chapter 20 References "]]
