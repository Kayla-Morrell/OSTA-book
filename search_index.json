[["index.html", "Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor Welcome", " Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor 2021-03-05 Welcome This is the website for the online textbook “Orchestrating Spatially Resolved Transcriptomics Analysis with Bioconductor” (OSTA). This textbook describes the steps in a computational analysis pipeline for spatially resolved transcriptomics (ST) data, using the Bioconductor framework and R programming language. The analysis pipeline is built up as a series of steps, each described in a chapter, with complete examples and workflows using R code and datasets that can be run on your own laptop. The book is organized into several parts, consisting of (i) introduction, (ii) preprocessing steps to prepare data for R, (iii) analysis steps, (iv) complete workflows, and (v) appendix. Additional details on analysis steps, as well as additional introductory material on R and Bioconductor, can be found in the related textbook Orchestrating Single-Cell Analysis with Bioconductor (OSCA). "],["introduction.html", "Chapter 1 Introduction 1.1 Contents of this book 1.2 Who this book is for 1.3 Bioconductor", " Chapter 1 Introduction This book describes a computational analysis pipeline for spatially resolved transcriptomics (ST) data, using the Bioconductor framework and R programming language. 1.1 Contents of this book The chapters are organized into several parts: Introduction: introduction, spatially resolved transcriptomics, and the SpatialExperiment object class Preprocessing steps: preprocessing steps to prepare raw data for loading into R Analysis steps: chapters describing key analysis steps using the Bioconductor framework, including examples of R code that can be run on your own laptop Workflows: complete workflows for several example datasets Appendix: contributors, acknowledgments, references 1.2 Who this book is for This book is intended for readers who have some experience with R, but does not assume any previous familiarity with Bioconductor. The examples and workflows include all R code required to download data, set up data objects, perform analyses, and visualize results. For readers who are new to R and Bioconductor, additional useful resources include: The Orchestrating Single-Cell Analysis with Bioconductor (OSCA) textbook, which contains additional details on the analysis steps described here in the context of single-cell RNA sequencing instead of ST data, as well as additional introductory chapters on R and Bioconductor The R for Data Science online textbook provides an excellent introduction to R Data Carpentry and Software Carpentry provide both introductory and more advanced online lesson materials on R programming, as well as the Unix shell and Git 1.3 Bioconductor Bioconductor is an open source and open development project, providing a cohesive yet flexible framework for analyzing high-throughput genomics data in R. The Bioconductor project consists of around 2000 contributed R packages, as well as core infrastructure maintained by the Bioconductor Core Team, providing a rich analysis environment for users. One of the main advantages of Bioconductor is the modularity and open development philosophy. R packages implementing analysis methods are contributed by numerous research groups, with the Bioconductor Core Team coordinating the overall project and maintaining infrastructure such as data object structures and package testing infrastructure. A key feature is that contributed packages are required to use consistent data structures, such as the SingleCellExperiment or SpatialExperiment object classes, which allows packages to interact nicely (e.g. output from one package can easily be provided as input to another package). In addition, Bioconductor packages are required to have comprehensive documentation, including “vignettes” (long-form examples including R code). This modular and open-development approach allows end users to readily combine and substitute analysis methods contributed by different research groups, instead of being “locked in” to using methods or packages maintained by a single group. In addition, anyone can contribute new packages implementing new methods to Bioconductor. "],["spatially-resolved-transcriptomics.html", "Chapter 2 Spatially resolved transcriptomics 2.1 10x Genomics Visium 2.2 Slide-seqV2 2.3 seqFISH 2.4 MERFISH 2.5 Other platforms", " Chapter 2 Spatially resolved transcriptomics Spatially resolved transcriptomics (ST) technologies allow transcriptome-wide gene expression to be measured at spatial resolution. There are several technological platforms, each with their unique advantages. 2.1 10x Genomics Visium The 10x Genomics Visium platform measures transcriptome-wide gene expression at a two-dimensional grid of “spots” on a tissue slide. Fresh-frozen tissue is placed onto the slide, fixed, stained, and permeabilized. Each spot contains millions of spatially-barcoded capture oligonucleotides, which bind to mRNAs from the tissue. A cDNA library is then generated for sequencing, which includes the spatial barcodes, allowing reads to be mapped back to their spatial locations. The dimensions of the tissue slide are approximately 6.5mm by 6.5mm, and contains around 5000 barcoded spots. Spots are located in a regular hexagonal arrangement, with each spot 55µm in diameter, and 100µm center to center. The number of cells per spot depends on the organism and tissue type, e.g. 0-10 for human brain, or around 50 for mouse brain. Each slide contains 4 capture areas (6.5mm x 6.5mm each). The following figure provides an illustration. Figure 2.1: Schematic of 10x Genomics Visium platform. Image source: 10x Genomics Visium website: https://www.10xgenomics.com/spatial-transcriptomics/ 2.2 Slide-seqV2 2.3 seqFISH 2.4 MERFISH 2.5 Other platforms "],["spatialexperiment.html", "Chapter 3 SpatialExperiment 3.1 SpatialExperiment class", " Chapter 3 SpatialExperiment In this book, we use the SpatialExperiment class from Bioconductor as the main data structure for storing data objects. 3.1 SpatialExperiment class SpatialExperiment is a specialized object class for storing spatially resolved transcriptomics datasets from several technological platforms within the Bioconductor framework. The class builds on the more general SingleCellExperiment class for single-cell RNA sequencing data, with additional customizations to store spatial information, such as spatial coordinates and image files. A summary of the SpatialExperiment object structure is show in the following figure. Briefly, a SpatialExperiment object consists of (i) assays containing expression counts, (ii) rowData containing information on features i.e. genes, (iii) colData containing information on spots or cells, (iv) spatialData containing spatial coordinates and other spatial information, and (v) imgData containing information on image files. For spot-based ST data (e.g. 10x Genomics Visium), a single assay named counts is used. For molecule-based ST data (e.g. seqFISH), two assays named counts and molecules are used. For more details, see our paper SpatialExperiment: infrastructure for spatially resolved transcriptomics data in R using Bioconductor (currently available as a preprint from bioRxiv). Figure 3.1: Overview of the SpatialExperiment object class for storing spatially resolved transcriptomics datasets in the Bioconductor framework. "],["preprocessing-steps.html", "Chapter 4 Preprocessing steps", " Chapter 4 Preprocessing steps In this part, we describe several crucial preprocessing steps required to prepare raw data files in order to load the data into R. These steps require the use of several tools outside Bioconductor. In these chapters, we primarily focus on the 10x Genomics Visium platform. "],["loupe-browser.html", "Chapter 5 Loupe Browser 5.1 Overview 5.2 Automatic alignment of images 5.3 Manual alignment of images 5.4 Output files for Space Ranger 5.5 Downstream analyses in Loupe Browser", " Chapter 5 Loupe Browser Draft structure and points to cover (but feel free to change) 5.1 Overview 5.2 Automatic alignment of images 5.3 Manual alignment of images 5.4 Output files for Space Ranger 5.5 Downstream analyses in Loupe Browser "],["image-segmentation.html", "Chapter 6 Image segmentation 6.1 Overview 6.2 Split histology images 6.3 File size issues 6.4 Segment cell nuclei 6.5 Identify number of cells per spot 6.6 Output files", " Chapter 6 Image segmentation Draft structure and points to cover (but feel free to change) 6.1 Overview 6.2 Split histology images 6.3 File size issues 6.4 Segment cell nuclei 6.5 Identify number of cells per spot 6.6 Output files "],["space-ranger.html", "Chapter 7 Space Ranger 7.1 Overview 7.2 Installation 7.3 Memory issues 7.4 Run spaceranger count 7.5 Output files 7.6 Web summary .html file 7.7 Import outputs into R", " Chapter 7 Space Ranger Draft structure and points to cover (but feel free to change) 7.1 Overview 7.2 Installation 7.3 Memory issues 7.4 Run spaceranger count 7.5 Output files 7.6 Web summary .html file 7.7 Import outputs into R "],["analysis-steps.html", "Chapter 8 Analysis steps 8.1 Load data 8.2 SpatialExperiment object structure", " Chapter 8 Analysis steps This part consists of several chapters for steps in a computational analysis pipeline for spatially resolved transcriptomics data. This includes quality control (QC), normalization, feature selection, dimensionality reduction, clustering, and identifying marker genes. These steps require that the raw data has been loaded into R. In the previous part, we provide detailed instructions and examples showing how to do this for the 10x Genomics Visium platform. Throughout these chapters, we follow the Bioconductor principle of modularity – if you prefer a different method for one of the steps, this can be substituted, the output stored in the SpatialExperiment object, and you can continue with the rest of the analysis pipeline. In several sections we describe several alternative methods within and outside Bioconductor. 8.1 Load data In the following analysis chapters, we use a pre-prepared dataset where we have previously applied the steps described in Preprocessing steps, and saved the object in the SpatialExperiment format. This is available from the STexampleData package. The dataset consists of a single sample of human brain from the dorsolateral prefrontal cortex (DLPFC) region, measured using the 10x Genomics Visium platform, from our publication Maynard et al. (2021). The dataset is described in more detail in Human DLPFC workflow. Here, we show how to load the data from STexampleData. library(SpatialExperiment) library(STexampleData) # load object spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) 8.2 SpatialExperiment object structure Inspect the SpatialExperiment object to understand the structure. For more details on SpatialExperiment, see SpatialExperiment. # inspect object spe ## class: SpatialExperiment ## dim: 33538 4992 ## metadata(0): ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): gene_id gene_name feature_type ## colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... ## TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 ## colData names(10): barcode_id imagerow ... pxl_col_in_fullres ## pxl_row_in_fullres ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialData names(4) : barcode_id in_tissue x y ## imgData names(4): sample_id image_id data scaleFactor dim(spe) ## [1] 33538 4992 assayNames(spe) ## [1] &quot;counts&quot; head(rowData(spe)) ## DataFrame with 6 rows and 3 columns ## gene_id gene_name feature_type ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSG00000243485 ENSG00000243485 MIR1302-2HG Gene Expression ## ENSG00000237613 ENSG00000237613 FAM138A Gene Expression ## ENSG00000186092 ENSG00000186092 OR4F5 Gene Expression ## ENSG00000238009 ENSG00000238009 AL627309.1 Gene Expression ## ENSG00000239945 ENSG00000239945 AL627309.3 Gene Expression ## ENSG00000239906 ENSG00000239906 AL627309.2 Gene Expression head(colData(spe)) ## DataFrame with 6 rows and 10 columns ## barcode_id imagerow imagecol cell_count ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 AAACAACGAATAGTTC-1 NA NA NA ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 381.098 440.639 6 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 126.328 259.631 16 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 427.768 183.078 5 ## AAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 186.814 417.237 2 ## AAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 341.269 152.700 4 ## ground_truth sample_id array_row array_col ## &lt;factor&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 NA sample_151673 0 16 ## AAACAAGTATCTCCCA-1 Layer3 sample_151673 50 102 ## AAACAATCTACTAGCA-1 Layer1 sample_151673 3 43 ## AAACACCAATAACTGC-1 WM sample_151673 59 19 ## AAACAGAGCGACTCCT-1 Layer3 sample_151673 14 94 ## AAACAGCTTTCAGAAG-1 Layer5 sample_151673 43 9 ## pxl_col_in_fullres pxl_row_in_fullres ## &lt;integer&gt; &lt;integer&gt; ## AAACAACGAATAGTTC-1 2435 3913 ## AAACAAGTATCTCCCA-1 8468 9791 ## AAACAATCTACTAGCA-1 2807 5769 ## AAACACCAATAACTGC-1 9505 4068 ## AAACAGAGCGACTCCT-1 4151 9271 ## AAACAGCTTTCAGAAG-1 7583 3393 head(spatialData(spe)) ## barcode_id in_tissue x y ## AAACAACGAATAGTTC-1 AAACAACGAATAGTTC-1 0 3913 10880 ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 1 9791 4847 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 1 5769 10508 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 1 4068 3810 ## AAACAGAGCGACTCCT-1 AAACAGAGCGACTCCT-1 1 9271 9164 ## AAACAGCTTTCAGAAG-1 AAACAGCTTTCAGAAG-1 1 3393 5732 imgData(spe) ## DataFrame with 2 rows and 4 columns ## sample_id image_id data scaleFactor ## &lt;character&gt; &lt;character&gt; &lt;list&gt; &lt;numeric&gt; ## 1 sample_151673 lowres #### 0.0450045 ## 2 sample_151673 hires #### 0.1500150 "],["quality-control.html", "Chapter 9 Quality control 9.1 Background 9.2 Load data 9.3 Plot data 9.4 Calculate QC metrics 9.5 Selecting thresholds 9.6 Zero-cell and single-cell spots 9.7 Quality control at gene level", " Chapter 9 Quality control 9.1 Background Quality control (QC) procedures at the spot level aim to remove low-quality spots before further analysis. Low-quality spots can occur due to problems during library preparation or other experimental procedures. Examples include large proportions of dead cells due to cell damage during library preparation, and low mRNA capture efficiency due to inefficient reverse transcription or PCR amplification. These spots are usually removed prior to further analysis, since otherwise they tend to create problems during downstream analyses such as clustering. For example, problematic spots that are not removed could show up as separate clusters, which may be misidentified as distinct cell types. Low-quality spots can be identified according to several characteristics, including: library size (i.e. total UMI counts per spot) number of expressed features (i.e. number of genes with non-zero UMI counts per spot) proportion of reads mapping to mitochondrial genes (a high proportion indicates cell damage) number of cells per spot (unusually high values can indicate problems) Low library size or low number of expressed features can indicate poor mRNA capture rates, e.g. due to cell damage and missing mRNAs, or low reaction efficiency. A high proportion of mitochondrial reads indicates cell damage, e.g. partial cell lysis leading to leakage and missing cytoplasmic mRNAs, with the resulting reads therefore concentrated on the remaining mitochondrial mRNAs that are relatively protected inside the mitochondrial membrane. Unusually high numbers of cells per spot can indicate problems during cell segmentation. The first three characteristics listed above are also used for QC in scRNA-seq data. However, the expected distributions for high-quality spots are different (compared to high-quality cells in scRNA-seq), since spots may contain zero, one, or multiple cells. 9.2 Load data library(SpatialExperiment) library(STexampleData) # load object spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) 9.3 Plot data As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected. We use visualization functions from the ggspavis package to generate plots. library(ggspavis) # plot spatial coordinates (spots) plotSpots(spe) 9.4 Calculate QC metrics We calculate the QC metrics described above with a combination of methods from the scater (McCarthy et al. 2017) package (for metrics that are also used for scRNA-seq data, where we treat spots as equivalent to cells) and our own functions. The QC metrics from scater can be calculated and added to the SpatialExperiment object as follows. Here, we also identify mitochondrial reads using their gene names, and pass these as an argument to scater. First, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we are not interested in. # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] dim(spe) ## [1] 33538 3639 library(scater) # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) table(is_mito) ## is_mito ## FALSE TRUE ## 33525 13 rowData(spe)$gene_name[is_mito] ## [1] &quot;MT-ND1&quot; &quot;MT-ND2&quot; &quot;MT-CO1&quot; &quot;MT-CO2&quot; &quot;MT-ATP8&quot; &quot;MT-ATP6&quot; &quot;MT-CO3&quot; ## [8] &quot;MT-ND3&quot; &quot;MT-ND4L&quot; &quot;MT-ND4&quot; &quot;MT-ND5&quot; &quot;MT-ND6&quot; &quot;MT-CYB&quot; # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) head(colData(spe), 3) ## DataFrame with 3 rows and 16 columns ## barcode_id imagerow imagecol cell_count ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 381.098 440.639 6 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 126.328 259.631 16 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 427.768 183.078 5 ## ground_truth sample_id array_row array_col ## &lt;factor&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 Layer3 sample_151673 50 102 ## AAACAATCTACTAGCA-1 Layer1 sample_151673 3 43 ## AAACACCAATAACTGC-1 WM sample_151673 59 19 ## pxl_col_in_fullres pxl_row_in_fullres sum detected ## &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 8468 9791 8458 3586 ## AAACAATCTACTAGCA-1 2807 5769 1667 1150 ## AAACACCAATAACTGC-1 9505 4068 3769 1960 ## subsets_mito_sum subsets_mito_detected subsets_mito_percent ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 1407 13 16.6351 ## AAACAATCTACTAGCA-1 204 11 12.2376 ## AAACACCAATAACTGC-1 430 13 11.4089 ## total ## &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 8458 ## AAACAATCTACTAGCA-1 1667 ## AAACACCAATAACTGC-1 3769 9.5 Selecting thresholds The simplest option to apply the QC metrics is to select thresholds for each metric, and remove any spots that do not meet the thresholds for one or more metrics. Exploratory visualizations can be used to help select appropriate thresholds, which may differ depending on the dataset. Here, we use visualizations to select thresholds for several QC metrics in our human DLPFC dataset: (i) library size, (ii) number of expressed genes, (iii) proportion of mitochondrial reads, and (iv) number of cells per spot. 9.5.1 Library size Library size represents the total sum of UMI counts per spot. This is included in the column labeled sum in the scater output. Plot a histogram of the library sizes across spots. # histogram of library sizes hist(colData(spe)$sum, breaks = 25) The distribution is relatively smooth, and there are no obvious issue such as a spike at very low library sizes. We also plot the library sizes against the number of cells per spot (which was included in the original data object). This is to check that we are not inadvertently removing a biologically meaningful group of spots. The horizontal line (argument threshold) shows our first guess at a possible filtering threshold for library size based on the histogram. library(spatzli) # plot library size vs. number of cells per spot plotQCscatter(spe, metric_x = &quot;cell_count&quot;, metric_y = &quot;sum&quot;, threshold_y = 500, marginal = TRUE) The plot shows that setting a filtering threshold for library size (e.g. at the value shown) does not appear to select for any obvious biologically consistent group of spots. We set a relatively arbitrary threshold of 500 UMI counts per spot, and then check the number of spots below this threshold. # select QC threshold for library size qc_lib_size &lt;- colData(spe)$sum &lt; 500 table(qc_lib_size) ## qc_lib_size ## FALSE TRUE ## 3632 7 colData(spe)$qc_lib_size &lt;- qc_lib_size Finally, we also check that the discarded spots do not have any obvious spatial pattern that correlates with known biological features. Otherwise, removing these spots could indicate that we have set the threshold too high, and are removing biologically informative spots. # check spatial pattern of discarded spots plotQCspots(spe, discard = &quot;qc_lib_size&quot;) As an aside, here we can also illustrate what happens if we set the threshold too high. For example, if we set the threshold to 1000 UMI counts per spot – which would also seem like a reasonable value based on the histogram and scatterplot – then we see a possible spatial pattern in the discarded spots, matching the cortical layers. This illustrates the importance of interactively checking exploratory visualizations when choosing these thresholds. # check spatial pattern of discarded spots if threshold is too high qc_lib_size_2000 &lt;- colData(spe)$sum &lt; 2000 colData(spe)$qc_lib_size_2000 &lt;- qc_lib_size_2000 plotQCspots(spe, discard = &quot;qc_lib_size_2000&quot;) For reference, here are the ground truth (manually annotated) cortical layers in this dataset. We use plotting functions from the ggspavis package. library(ggspavis) # plot ground truth (manually annotated) layers plotSpots(spe, discrete = &quot;ground_truth&quot;, palette = &quot;libd_layer_colors&quot;) ## Warning: Removed 28 rows containing missing values (geom_point). 9.5.2 Number of expressed features The number of expressed features refers to the number of genes with non-zero UMI counts per spot. This is stored in the column detected in the scater output. We use a similar sequence of visualizations to choose a threshold for this QC metric. # histogram of numbers of expressed genes hist(colData(spe)$detected, breaks = 25) # plot number of expressed genes vs. number of cells per spot plotQCscatter(spe, metric_x = &quot;cell_count&quot;, metric_y = &quot;detected&quot;, threshold_y = 250, marginal = TRUE) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; Based on the plots, we select a threshold of 250 expressed genes per spot. # select QC threshold for number of expressed genes qc_detected &lt;- colData(spe)$detected &lt; 250 table(qc_detected) ## qc_detected ## FALSE TRUE ## 3634 5 colData(spe)$qc_detected &lt;- qc_detected # check spatial pattern of discarded spots plotQCspots(spe, discard = &quot;qc_detected&quot;) Again, we also check what happens when we set the threshold too high. # check spatial pattern of discarded spots if threshold is too high qc_detected_1000 &lt;- colData(spe)$detected &lt; 1000 colData(spe)$qc_detected_1000 &lt;- qc_detected_1000 plotQCspots(spe, discard = &quot;qc_detected_1000&quot;) 9.5.3 Proportion of mitochondrial reads A high proportion of mitochondrial reads indicates cell damage. We investigate the proportions of mitochondrial reads across spots, and select an appropriate threshold. The proportions of mitochondrial reads per spot are stored in the column subsets_mito_percent in the scater output. # histogram of mitochondrial read proportions hist(colData(spe)$subsets_mito_percent, breaks = 25) # plot mitochondrial read proportion vs. number of cells per spot plotQCscatter(spe, metric_x = &quot;cell_count&quot;, metric_y = &quot;subsets_mito_percent&quot;, threshold_y = 30, marginal = TRUE) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; We select a threshold of 30% for the mitochondrial read proportion. # select QC threshold for mitochondrial read proportion qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 table(qc_mito) ## qc_mito ## FALSE TRUE ## 3636 3 colData(spe)$qc_mito &lt;- qc_mito # check spatial pattern of discarded spots plotQCspots(spe, discard = &quot;qc_mito&quot;) We also check what happens when we set the threshold too low. # check spatial pattern of discarded spots if threshold is too high qc_mito_25 &lt;- colData(spe)$subsets_mito_percent &gt; 25 colData(spe)$qc_mito_25 &lt;- qc_mito_25 plotQCspots(spe, discard = &quot;qc_mito_25&quot;) 9.5.4 Number of cells per spot The number of cells per spot depends on the tissue type and organism. Here, we check for any outlier values that could indicate problems during cell segmentation. # histogram of cell counts hist(colData(spe)$cell_count, breaks = 25) # distribution of cells per spot tbl_cells_per_spot &lt;- table(colData(spe)$cell_count) We see a tail of very high values, which could indicate problems for these spots. These values are also visible on the scatterplots. Here, we again plot the number of expressed genes vs. cell count, with an added trend. # plot number of expressed genes vs. number of cells per spot plotQCscatter(spe, metric_x = &quot;cell_count&quot;, metric_y = &quot;detected&quot;, threshold_x = 12, trend = TRUE, marginal = TRUE) ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; ## `geom_smooth()` using formula &#39;y ~ x&#39; In particular, we see that the spots with very high cell counts also have low numbers of expressed genes. This indicates that the experiments have failed for these spots, and they should be removed. We select a threshold of 12 cells per spot. The number of spots above this threshold is relatively small, and there is a clear downward trend in the number of expressed genes above this threshold. # select QC threshold for number of cells per spot qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 table(qc_cell_count) ## qc_cell_count ## FALSE TRUE ## 3592 47 colData(spe)$qc_cell_count &lt;- qc_cell_count # check spatial pattern of discarded spots plotQCspots(spe, discard = &quot;qc_cell_count&quot;) While there is a spatial pattern to the discarded spots, it does not appear to be correlated with the known biological features (cortical layers). The discarded spots are all on the edges of the tissue. It seems plausible that something has gone wrong with the cell segmentation on the edges of the images, so it makes sense to remove these spots. 9.5.5 Remove low-quality spots Now that we have calculated several QC metrics and selected thresholds for each one, we can combine the sets of low-quality spots, and remove them from our object. We also check again that the combined set of discarded spots does not correspond to any obvious biologically relevant group of spots. # number of discarded spots for each metric apply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum) ## qc_lib_size qc_detected qc_mito qc_cell_count ## 7 5 3 47 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count table(discard) ## discard ## FALSE TRUE ## 3582 57 # store in object colData(spe)$discard &lt;- discard # check spatial pattern of combined set of discarded spots plotQCspots(spe, discard = &quot;discard&quot;) # remove combined set of low-quality spots spe &lt;- spe[, !colData(spe)$discard] dim(spe) ## [1] 33538 3582 9.6 Zero-cell and single-cell spots A particular characteristic of Visium data is that spots can contain zero, one, or multiple cells. We could also imagine other filtering procedures such as (i) removing spots with zero cells, or (ii) restricting the analysis to spots containing a single cell (which would make the data more similar to scRNA-seq). However, this would discard a large amount of information. Below, we show the distribution of cells per spot again (up to the filtering threshold of 12 cells per spot from above). # distribution of cells per spot tbl_cells_per_spot[1:13] ## ## 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 84 211 483 623 617 541 421 287 140 92 50 25 18 # as proportions prop_cells_per_spot &lt;- round(tbl_cells_per_spot / sum(tbl_cells_per_spot), 2) prop_cells_per_spot[1:13] ## ## 0 1 2 3 4 5 6 7 8 9 10 11 12 ## 0.02 0.06 0.13 0.17 0.17 0.15 0.12 0.08 0.04 0.03 0.01 0.01 0.00 Only 6% of spots contain a single cell. If we restricted the analysis to these spots only, we would be discarding most of the data. Removing the spots containing zero cells (2% of spots) would also be problematic, since these spots can also contain biologically meaningful information. For example, in this brain dataset, the regions between cell bodies consists of neuropil (dense networks of axons and dendrites). In our paper (Maynard et al. 2021), we explore the information contained in these neuropil spots. 9.7 Quality control at gene level The sections above consider quality control at the spot level. In some datasets, it may also be appropriate to apply quality control procedures or filtering at the gene level. For example, certain genes may be biologically irrelevant for downstream analyses. However, here we make a distinction between quality control and feature selection. Removing biologically uninteresting genes (such as mitochondrial genes) may also be considered as part of feature selection, since there is no underlying experimental procedure that has failed. Therefore, we will discuss gene-level filtering in the Feature selection chapter. "],["normalization.html", "Chapter 10 Normalization 10.1 Background 10.2 Previous steps 10.3 Log-transformed normalized counts", " Chapter 10 Normalization 10.1 Background Details on normalization in single-cell and spatial data. 10.2 Previous steps Code to run steps from the previous chapters, to generate the SpatialExperiment object required for this chapter. # --------- # load data # --------- library(SpatialExperiment) library(STexampleData) spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) # -------------------- # quality control (QC) # -------------------- library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] 10.3 Log-transformed normalized counts Calculate log-transformed normalized counts (abbreviated as “logcounts”), using pool-based size factors and deconvolution to the spot level. We use normalization methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016), which were originally developed for single-cell RNA sequencing data. We make the assumption that these methods can be applied here by treating spots as equivalent to cells. Since we have only a single sample, there are no blocking factors in the experimental design. library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) table(qclus) ## qclus ## 1 2 3 4 5 6 7 8 9 10 ## 372 245 254 744 415 230 394 299 492 137 # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) summary(sizeFactors(spe)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1334 0.6093 0.8844 1.0000 1.2852 4.2475 hist(sizeFactors(spe), breaks = 20) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) # check assayNames(spe) ## [1] &quot;counts&quot; &quot;logcounts&quot; dim(counts(spe)) ## [1] 33538 3582 dim(logcounts(spe)) ## [1] 33538 3582 "],["feature-selection.html", "Chapter 11 Feature selection 11.1 Background 11.2 Previous steps 11.3 Highly variable genes (HVGs) 11.4 Spatially variable genes (SVGs)", " Chapter 11 Feature selection 11.1 Background Chapter on feature selection, including standard single-cell methods as well as new methods developed for ST data. 11.2 Previous steps Code to run steps from the previous chapters, to generate the SpatialExperiment object required for this chapter. # --------- # load data # --------- library(SpatialExperiment) library(STexampleData) spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) # -------------------- # quality control (QC) # -------------------- library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # ------------- # normalization # ------------- library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) 11.3 Highly variable genes (HVGs) We use methods from scran (Lun, McCarthy, and Marioni 2016) to identify a set of top highly variable genes (HVGs), which will be used to define cell types. These methods were originally developed for single-cell RNA sequencing, so here we assume that spots can be treated as equivalent to cells, and we use only molecular features (gene expression). First, we remove mitochondrial genes, since these are very highly expressed in this dataset, and are not of biological interest. # remove mitochondrial genes spe &lt;- spe[!is_mito, ] dim(spe) ## [1] 33525 3582 Then, apply methods from scran. This gives us a list of HVGs, which can be used for further downstream analyses. library(scran) # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # visualize mean-variance relationship fit &lt;- metadata(dec) plot(fit$mean, fit$var, xlab = &quot;mean of log-expression&quot;, ylab = &quot;variance of log-expression&quot;) curve(fit$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) length(top_hvgs) ## [1] 1448 11.4 Spatially variable genes (SVGs) Section on alternative methods for SVGs 11.4.1 SpatialDE SpatialDE (Svensson, Teichmann, and Stegle 2018) 11.4.2 SPARK SPARK (Sun, Zhu, and Zhou 2020) 11.4.3 Moran’s I statistic Moran’s I statistic 11.4.4 Further methods Further methods "],["dimensionality-reduction.html", "Chapter 12 Dimensionality reduction 12.1 Background 12.2 Previous steps 12.3 Principal component analysis (PCA) 12.4 Uniform Manifold Approximation and Projection (UMAP) 12.5 Visualizations", " Chapter 12 Dimensionality reduction 12.1 Background Chapter on dimensionality reduction 12.2 Previous steps Code to run steps from the previous chapters, to generate the SpatialExperiment object required for this chapter. # --------- # load data # --------- library(SpatialExperiment) library(STexampleData) spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) # -------------------- # quality control (QC) # -------------------- library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # ------------- # normalization # ------------- library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) # ----------------- # feature selection # ----------------- # remove mitochondrial genes spe &lt;- spe[!is_mito, ] # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) 12.3 Principal component analysis (PCA) Apply principal component analysis (PCA) to the set of top highly variable genes (HVGs) to reduce the dimensionality of the dataset, and retain the top 50 principal components (PCs) for further downstream analyses. This is done for two reasons: (i) to reduce noise due to random variation in expression of biologically uninteresting genes, which are assumed to have expression patterns that are independent of each other, and (ii) to improve computational efficiency during downstream analyses. We use the computationally efficient implementation of PCA provided in the scater package (McCarthy et al. 2017). This implementation uses randomization, and therefore requires setting a random seed for reproducibility. # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) reducedDimNames(spe) ## [1] &quot;PCA&quot; dim(reducedDim(spe, &quot;PCA&quot;)) ## [1] 3582 50 12.4 Uniform Manifold Approximation and Projection (UMAP) We also run UMAP (McInnes, Healy, and Melville 2018) on the set of top 50 PCs and retain the top 2 UMAP components, which will be used for visualization purposes. # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) reducedDimNames(spe) ## [1] &quot;PCA&quot; &quot;UMAP&quot; dim(reducedDim(spe, &quot;UMAP&quot;)) ## [1] 3582 2 # update column names for plotting functions colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 12.5 Visualizations Generate plots using plotting functions from the ggspavis package. In the next chapter on clustering, we will add cluster labels to these reduced dimension plots. library(ggspavis) # plot top 2 PCA dimensions plotDimRed(spe, type = &quot;PCA&quot;) # plot top 2 UMAP dimensions plotDimRed(spe, type = &quot;UMAP&quot;) "],["clustering.html", "Chapter 13 Clustering 13.1 Overview 13.2 Previous steps 13.3 Clustering on HVGs 13.4 Clustering on HVGs and spatial dimensions 13.5 BayesSpace 13.6 Further methods", " Chapter 13 Clustering 13.1 Overview Clustering is used in single-cell and spatial analysis to identify cell types. The definition of “cell type” is somewhat nebulous, and can depend to some extent on the biological context. Major cell types are generally well-defined and well-characterized (e.g. T cells, B cells, etc), while the definitions of more subtle or higher-resolution cell types may be somewhat less clear. In the spatial context, we may be interested in e.g. (i) identifying cell types that occur in biologically interesting spatial patterns, or (ii) identifying major cell types and performing subsequent analyses within these cell types. 13.2 Previous steps Code to run steps from the previous chapters, to generate the SpatialExperiment object required for this chapter. # --------- # load data # --------- library(SpatialExperiment) library(STexampleData) spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) # -------------------- # quality control (QC) # -------------------- library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # ------------- # normalization # ------------- library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) # ----------------- # feature selection # ----------------- # remove mitochondrial genes spe &lt;- spe[!is_mito, ] # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) # ------------------------ # dimensionality reduction # ------------------------ # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) # update column names for plotting functions colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 13.3 Clustering on HVGs We can perform clustering by applying standard clustering methods developed for single-cell RNA sequencing data, using molecular features (gene expression). Here, we apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs. In the context of spatial data, this means we assume that biologically informative spatial distribution patterns of cell types can be detected from the molecular features (gene expression). Below, we also discuss alternative methods that directly take spatial information into account during clustering. # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership table(clus) ## clus ## 1 2 3 4 5 6 ## 372 916 342 1083 349 520 # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) Visualize the clusters by plotting in (i) spatial x-y coordinates on the tissue slide, and (ii) reduced dimension space (PCA or UMAP). We use plotting functions from the ggspavis package. For reference, we also display the ground truth (manually annotated) labels available for this dataset (in spatial x-y coordinates). From the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly. library(ggspavis) # plot clusters in spatial x-y coordinates plotSpots(spe, discrete = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) # plot ground truth labels in spatial x-y coordinates plotSpots(spe, discrete = &quot;ground_truth&quot;, palette = &quot;libd_layer_colors&quot;) ## Warning: Removed 14 rows containing missing values (geom_point). # plot clusters in PCA reduced dimensions plotDimRed(spe, type = &quot;PCA&quot;, discrete = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) # plot clusters in UMAP reduced dimensions plotDimRed(spe, type = &quot;UMAP&quot;, discrete = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) 13.4 Clustering on HVGs and spatial dimensions Section on approach from our publication Maynard et al. (2021) to combine molecular and spatial features with appropriate scaling. 13.5 BayesSpace Section on BayesSpace (Zhao et al. 2020); available in Bioconductor 13.6 Further methods Further methods "],["marker-genes.html", "Chapter 14 Marker genes 14.1 Background 14.2 Previous steps 14.3 Marker genes", " Chapter 14 Marker genes 14.1 Background Chapter on identifying marker genes for clusters by differential gene expression testing. 14.2 Previous steps Code to run steps from the previous chapters, to generate the SpatialExperiment object required for this chapter. # --------- # load data # --------- library(SpatialExperiment) library(STexampleData) spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) # -------------------- # quality control (QC) # -------------------- library(scater) # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count colData(spe)$discard &lt;- discard # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] # ------------- # normalization # ------------- library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) # ----------------- # feature selection # ----------------- # remove mitochondrial genes spe &lt;- spe[!is_mito, ] # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) # ------------------------ # dimensionality reduction # ------------------------ # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) # update column names for plotting functions colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) # ---------- # clustering # ---------- # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) 14.3 Marker genes Identify marker genes by testing for differential gene expression between clusters. We use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs. not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally. library(scran) # set gene names as row names for visualization purposes rownames(spe) &lt;- rowData(spe)$gene_name # test for marker genes markers &lt;- findMarkers(spe, test = &quot;binom&quot;, direction = &quot;up&quot;) # returns a list with one DataFrame per cluster markers ## List of length 6 ## names(6): 1 2 3 4 5 6 library(pheatmap) # plot log-fold changes for one cluster over all other clusters # selecting cluster 1 interesting &lt;- markers[[1]] best_set &lt;- interesting[interesting$Top &lt;= 5, ] logFCs &lt;- getMarkerEffects(best_set) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) library(scater) # plot log-transformed normalized expression of top genes for one cluster top_genes &lt;- head(rownames(interesting)) plotExpression(spe, x = &quot;label&quot;, features = top_genes) "],["workflows.html", "Chapter 15 Workflows", " Chapter 15 Workflows In this part, each chapter contains a complete workflow for one dataset, with minimal documentation. This shows how the individual analysis steps described in the previous part fit together. For more details on any of the individual analysis steps, see the previous chapters. "],["human-dlpfc-workflow.html", "Chapter 16 Human DLPFC workflow 16.1 Description of dataset 16.2 Load data 16.3 Plot data 16.4 Quality control (QC) 16.5 Normalization 16.6 Feature selection 16.7 Dimensionality reduction 16.8 Clustering 16.9 Marker genes", " Chapter 16 Human DLPFC workflow This workflow analyzes one sample of human brain from the dorsolateral prefrontal cortex (DLPFC) region, measured using the 10x Genomics Visium platform. This is a condensed version of the analyses shown in the individual analysis chapters in the previous part. For more details on any of the individual steps, see the previous chapters. 16.1 Description of dataset This is a 10x Genomics Visium dataset generated from healthy human brain samples from the dorsolateral prefrontal cortex (DLPFC) region. In the full dataset, there are 12 samples in total, from 3 individuals, with 2 pairs of “spatially adjacent” replicates (serial sections) per individual (4 samples per individual). The individuals and spatially adjacent replicates can be considered as blocking factors. Each sample spans the six layers of the cortex plus white matter in a perpendicular tissue section. For the examples in this workflow and the analysis chapters, we use a single sample from this dataset (sample 151673), mainly to reduce computational requirements to compile the book. This dataset is described in our publication Maynard et al. (2021). The full dataset is publicly available through the spatialLIBD Bioconductor package, and the analysis code from our paper is provided in the HumanPilot GitHub repository. The dataset can also be explored interactively through the spatialLIBD Shiny web app. 16.2 Load data Here, we load a single sample from this dataset (sample 151673), which is available as a SpatialExperiment object from the STexampleData package. library(SpatialExperiment) library(STexampleData) # load object spe &lt;- load_data(&quot;Visium_humanDLPFC&quot;) spe ## class: SpatialExperiment ## dim: 33538 4992 ## metadata(0): ## assays(1): counts ## rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 ## ENSG00000268674 ## rowData names(3): gene_id gene_name feature_type ## colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... ## TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 ## colData names(10): barcode_id imagerow ... pxl_col_in_fullres ## pxl_row_in_fullres ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialData names(4) : barcode_id in_tissue x y ## imgData names(4): sample_id image_id data scaleFactor 16.3 Plot data As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide, to check that the object has loaded correctly and that the orientation is as expected. We use visualization functions from the ggspavis package to generate plots. library(ggspavis) # plot spatial coordinates (spots) plotSpots(spe) 16.4 Quality control (QC) First, we subset the object to keep only spots over tissue. The remaining spots are background spots, which we are not interested in. # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] dim(spe) ## [1] 33538 3639 Next, calculate spot-level QC metrics using the scater package (McCarthy et al. 2017), and store the QC metrics in colData. See Quality control for more details, including explanations of the QC metrics. library(scater) # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) table(is_mito) ## is_mito ## FALSE TRUE ## 33525 13 rowData(spe)$gene_name[is_mito] ## [1] &quot;MT-ND1&quot; &quot;MT-ND2&quot; &quot;MT-CO1&quot; &quot;MT-CO2&quot; &quot;MT-ATP8&quot; &quot;MT-ATP6&quot; &quot;MT-CO3&quot; ## [8] &quot;MT-ND3&quot; &quot;MT-ND4L&quot; &quot;MT-ND4&quot; &quot;MT-ND5&quot; &quot;MT-ND6&quot; &quot;MT-CYB&quot; # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) head(colData(spe), 3) ## DataFrame with 3 rows and 16 columns ## barcode_id imagerow imagecol cell_count ## &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 381.098 440.639 6 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 126.328 259.631 16 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 427.768 183.078 5 ## ground_truth sample_id array_row array_col ## &lt;factor&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 Layer3 sample_151673 50 102 ## AAACAATCTACTAGCA-1 Layer1 sample_151673 3 43 ## AAACACCAATAACTGC-1 WM sample_151673 59 19 ## pxl_col_in_fullres pxl_row_in_fullres sum detected ## &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 8468 9791 8458 3586 ## AAACAATCTACTAGCA-1 2807 5769 1667 1150 ## AAACACCAATAACTGC-1 9505 4068 3769 1960 ## subsets_mito_sum subsets_mito_detected subsets_mito_percent ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 1407 13 16.6351 ## AAACAATCTACTAGCA-1 204 11 12.2376 ## AAACACCAATAACTGC-1 430 13 11.4089 ## total ## &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 8458 ## AAACAATCTACTAGCA-1 1667 ## AAACACCAATAACTGC-1 3769 Select filtering thresholds for the QC metrics by examining distributions using histograms. For additional details, including further exploratory visualizations to select the thresholds, see Quality control. Here, we use relatively relaxed thresholds, since the additional exploratory visualizations showed that more stringent thresholds tended to remove groups of spots corresponding to biologically meaningful regions. # histograms of QC metrics par(mfrow = c(1, 4)) hist(colData(spe)$sum, xlab = &quot;sum&quot;, main = &quot;UMIs per spot&quot;) hist(colData(spe)$detected, xlab = &quot;detected&quot;, main = &quot;Genes per spot&quot;) hist(colData(spe)$subsets_mito_percent, xlab = &quot;percent mitochondrial&quot;, main = &quot;Percent mito UMIs&quot;) hist(colData(spe)$cell_count, xlab = &quot;number of cells&quot;, main = &quot;No. cells per spot&quot;) par(mfrow = c(1, 1)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 500 qc_detected &lt;- colData(spe)$detected &lt; 250 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 qc_cell_count &lt;- colData(spe)$cell_count &gt; 12 # number of discarded spots for each metric apply(cbind(qc_lib_size, qc_detected, qc_mito, qc_cell_count), 2, sum) ## qc_lib_size qc_detected qc_mito qc_cell_count ## 7 5 3 47 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito | qc_cell_count table(discard) ## discard ## FALSE TRUE ## 3582 57 # store in object colData(spe)$discard &lt;- discard Plot the set of discarded spots in the spatial x-y coordinates, to confirm that the spatial distribution of the discarded spots does not correspond to any biologically meaningful regions, which would indicate that we are removing biologically informative spots. We use QC visualization functions from the spatzli package to generate plots. library(spatzli) # check spatial pattern of discarded spots plotQCspots(spe, discard = &quot;discard&quot;) There is some concentration of discarded spots at the edge of the tissue region, which may be due to tissue damage. Importantly, the discarded spots do not correspond to any of the cortical layers of interest. We filter out the low-quality spots from the object. # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] dim(spe) ## [1] 33538 3582 16.5 Normalization Calculate log-transformed normalized counts, using pool-based size factors and deconvolution to the spot level. We use normalization methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016), by assuming that these methods can be applied by treating spots as equivalent to cells. Since we have a single sample, there are no blocking factors. For more details, see Normalization. library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) table(qclus) ## qclus ## 1 2 3 4 5 6 7 8 9 10 ## 372 245 254 744 415 230 394 299 492 137 # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) summary(sizeFactors(spe)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1334 0.6093 0.8844 1.0000 1.2852 4.2475 hist(sizeFactors(spe), breaks = 20) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) assayNames(spe) ## [1] &quot;counts&quot; &quot;logcounts&quot; 16.6 Feature selection Identify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from scran (Lun, McCarthy, and Marioni 2016), treating spots as equivalent to cells, and considering only molecular features (gene expression). Alternative methods adapted for spatial data will be described in Feature selection. We also first filter out mitochondrial genes, since these are very highly expressed and not of biological interest here. # remove mitochondrial genes spe &lt;- spe[!is_mito, ] dim(spe) ## [1] 33525 3582 # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # visualize mean-variance relationship fit &lt;- metadata(dec) plot(fit$mean, fit$var, xlab = &quot;mean of log-expression&quot;, ylab = &quot;variance of log-expression&quot;) curve(fit$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) length(top_hvgs) ## [1] 1448 16.7 Dimensionality reduction Run principal component analysis (PCA) to the set of top HVGs, and retain the top 50 principal components (PCs) for further downstream analyses. This is done both to reduce noise and to improve computational efficiency. We also run UMAP on the set of top 50 PCs and retain the top 2 UMAP components for visualization purposes. We use the computationally efficient implementation of PCA available in scater (McCarthy et al. 2017), which uses randomization, and therefore requires setting a random seed for reproducibility. # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) reducedDimNames(spe) ## [1] &quot;PCA&quot; dim(reducedDim(spe, &quot;PCA&quot;)) ## [1] 3582 50 # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) reducedDimNames(spe) ## [1] &quot;PCA&quot; &quot;UMAP&quot; dim(reducedDim(spe, &quot;UMAP&quot;)) ## [1] 3582 2 # update column names for plotting functions colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 16.8 Clustering Next, we perform clustering to define cell types. Here, we use molecular features (gene expression) only. Alternative approaches for spatial data that take into account spatial and other features will be described in Clustering. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs. # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership table(clus) ## clus ## 1 2 3 4 5 6 ## 372 916 342 1083 349 520 # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) Visualize the clusters by plotting in (i) spatial x-y coordinates on the tissue slide, and (ii) UMAP dimensions. We use plotting functions from the ggspavis package. From the visualizations, we can see that the clustering reproduces the known biological structure (cortical layers), although not perfectly. The clusters are also separated in UMAP space, but again not perfectly. library(ggspavis) # plot clusters in spatial x-y coordinates plotSpots(spe, discrete = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) # plot ground truth labels in spatial x-y coordinates plotSpots(spe, discrete = &quot;ground_truth&quot;, palette = &quot;libd_layer_colors&quot;) ## Warning: Removed 14 rows containing missing values (geom_point). # plot clusters in UMAP reduced dimensions plotDimRed(spe, type = &quot;UMAP&quot;, discrete = &quot;label&quot;, palette = &quot;libd_layer_colors&quot;) 16.9 Marker genes Identify marker genes by testing for differential gene expression between clusters. We use the findMarkers implementation in scran (Lun, McCarthy, and Marioni 2016), using a binomial test, which tests for genes that differ in the proportion expressed vs. not expressed between clusters. This is a more stringent test than the default t-tests, and tends to select genes that are easier to interpret and validate experimentally. # set gene names as row names for visualization purposes rownames(spe) &lt;- rowData(spe)$gene_name # test for marker genes markers &lt;- findMarkers(spe, test = &quot;binom&quot;, direction = &quot;up&quot;) # returns a list with one DataFrame per cluster markers ## List of length 6 ## names(6): 1 2 3 4 5 6 library(pheatmap) # plot log-fold changes for one cluster over all other clusters # selecting cluster 1 interesting &lt;- markers[[1]] best_set &lt;- interesting[interesting$Top &lt;= 5, ] logFCs &lt;- getMarkerEffects(best_set) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) # plot log-transformed normalized expression of top genes for one cluster top_genes &lt;- head(rownames(interesting)) plotExpression(spe, x = &quot;label&quot;, features = top_genes) "],["mouse-coronal-workflow.html", "Chapter 17 Mouse coronal workflow 17.1 Description of dataset 17.2 Load data 17.3 Plot data 17.4 Quality control (QC) 17.5 Normalization 17.6 Feature selection 17.7 Dimensionality reduction 17.8 Clustering 17.9 Marker genes", " Chapter 17 Mouse coronal workflow This workflow analyzes a mouse coronal brain section dataset from the 10x Genomics Visium platform. This dataset was generated by 10x Genomics, and the raw data files are publicly available from the 10x Genomics website. 17.1 Description of dataset This dataset measures transcriptome-wide gene expression on a Visium slide spanning one hemisphere of a mouse coronal brain section. For experimental details, see the 10x Genomics website. Due to the small size of the mouse brain and the dimensions of the Visium slide (6.5mm x 6.5mm), the measurements span an entire brain hemisphere. Therefore, we can use this dataset to compare gene expression profiles between major anatomical regions of the mouse brain. Due to the small size of cells in the mouse brain, each spot can contain up to 50 cells. In this dataset, we do not know the exact number of cells per spot. 17.2 Load data The dataset is available in SpatialExperiment format from the STexampleData package. library(SpatialExperiment) library(STexampleData) # load object spe &lt;- load_data(&quot;Visium_mouseCoronal&quot;) spe ## class: SpatialExperiment ## dim: 32285 4992 ## metadata(0): ## assays(1): counts ## rownames(32285): ENSMUSG00000051951 ENSMUSG00000089699 ... ## ENSMUSG00000095019 ENSMUSG00000095041 ## rowData names(3): gene_id gene_name feature_type ## colnames(4992): AAACAACGAATAGTTC-1 AAACAAGTATCTCCCA-1 ... ## TTGTTTGTATTACACG-1 TTGTTTGTGTAAATTC-1 ## colData names(6): barcode_id sample_id ... pxl_col_in_fullres ## pxl_row_in_fullres ## reducedDimNames(0): ## mainExpName: NULL ## altExpNames(0): ## spatialData names(4) : barcode_id in_tissue x y ## imgData names(4): sample_id image_id data scaleFactor 17.3 Plot data As an initial check, plot the spatial coordinates (spots) in x-y dimensions on the tissue slide. This confirms that the object has loaded correctly, and the orientation matches the 10x Genomics website. We use visualization functions from the ggspavis package to generate plots. library(ggspavis) # plot spatial coordinates (spots) plotSpots(spe) 17.4 Quality control (QC) Subset object to keep only spots over tissue. # subset to keep only spots over tissue spe &lt;- spe[, spatialData(spe)$in_tissue == 1] dim(spe) ## [1] 32285 2702 Calculate spot-level QC metrics using the scater package (McCarthy et al. 2017), and store the QC metrics in colData. library(scater) # identify mitochondrial genes is_mito &lt;- grepl(&quot;(^MT-)|(^mt-)&quot;, rowData(spe)$gene_name) table(is_mito) ## is_mito ## FALSE TRUE ## 32272 13 rowData(spe)$gene_name[is_mito] ## [1] &quot;mt-Nd1&quot; &quot;mt-Nd2&quot; &quot;mt-Co1&quot; &quot;mt-Co2&quot; &quot;mt-Atp8&quot; &quot;mt-Atp6&quot; &quot;mt-Co3&quot; ## [8] &quot;mt-Nd3&quot; &quot;mt-Nd4l&quot; &quot;mt-Nd4&quot; &quot;mt-Nd5&quot; &quot;mt-Nd6&quot; &quot;mt-Cytb&quot; # calculate per-spot QC metrics and store in colData spe &lt;- addPerCellQC(spe, subsets = list(mito = is_mito)) head(colData(spe), 3) ## DataFrame with 3 rows and 12 columns ## barcode_id sample_id array_row array_col ## &lt;character&gt; &lt;character&gt; &lt;integer&gt; &lt;integer&gt; ## AAACAAGTATCTCCCA-1 AAACAAGTATCTCCCA-1 sample_01 50 102 ## AAACAATCTACTAGCA-1 AAACAATCTACTAGCA-1 sample_01 3 43 ## AAACACCAATAACTGC-1 AAACACCAATAACTGC-1 sample_01 59 19 ## pxl_col_in_fullres pxl_row_in_fullres sum detected ## &lt;integer&gt; &lt;integer&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 7237 8229 20935 5230 ## AAACAATCTACTAGCA-1 1611 4169 14789 3646 ## AAACACCAATAACTGC-1 8315 2518 34646 6272 ## subsets_mito_sum subsets_mito_detected subsets_mito_percent ## &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 4036 13 19.2787 ## AAACAATCTACTAGCA-1 3419 13 23.1185 ## AAACACCAATAACTGC-1 5068 13 14.6280 ## total ## &lt;numeric&gt; ## AAACAAGTATCTCCCA-1 20935 ## AAACAATCTACTAGCA-1 14789 ## AAACACCAATAACTGC-1 34646 Select filtering thresholds for the QC metrics by examining distributions using histograms. # histograms of QC metrics par(mfrow = c(1, 3)) hist(colData(spe)$sum, xlab = &quot;sum&quot;, main = &quot;UMIs per spot&quot;) hist(colData(spe)$detected, xlab = &quot;detected&quot;, main = &quot;Genes per spot&quot;) hist(colData(spe)$subsets_mito_percent, xlab = &quot;percent mitochondrial&quot;, main = &quot;Percent mito UMIs&quot;) par(mfrow = c(1, 1)) # select QC thresholds qc_lib_size &lt;- colData(spe)$sum &lt; 5000 qc_detected &lt;- colData(spe)$detected &lt; 1000 qc_mito &lt;- colData(spe)$subsets_mito_percent &gt; 30 # number of discarded spots for each QC metric apply(cbind(qc_lib_size, qc_detected, qc_mito), 2, sum) ## qc_lib_size qc_detected qc_mito ## 9 4 11 # combined set of discarded spots discard &lt;- qc_lib_size | qc_detected | qc_mito table(discard) ## discard ## FALSE TRUE ## 2683 19 # store in object colData(spe)$discard &lt;- discard Plot discarded spots in x-y coordinates on the tissue slide to check if there is any biologically meaningful spatial pattern. This would be problematic, since it would mean we are removing biologically informative spots. We use QC visualization functions from the spatzli package to generate plots. library(spatzli) # check spatial pattern of discarded spots plotQCspots(spe, discard = &quot;discard&quot;) There is one small region with some concentrated discarded spots at the top-left. However, this does not appear to correspond to any specific known anatomical region of interest. We assume that these are low-quality spots, and filtering them out will not cause problems in the biological interpretation. We filter out the low-quality spots from the object. # filter low-quality spots spe &lt;- spe[, !colData(spe)$discard] dim(spe) ## [1] 32285 2683 17.5 Normalization Next, we calculate log-transformed normalized counts, using pool-based size factors and deconvolution to the spot level, using methods from scater (McCarthy et al. 2017) and scran (Lun, McCarthy, and Marioni 2016). Since we have a single sample, there are no blocking factors in the experimental design. library(scran) # quick clustering for pool-based size factors set.seed(123) qclus &lt;- quickCluster(spe) table(qclus) ## qclus ## 1 2 3 4 5 6 7 8 9 10 11 12 ## 178 162 255 450 274 235 320 250 105 119 131 204 # calculate size factors and store in object spe &lt;- computeSumFactors(spe, cluster = qclus) summary(sizeFactors(spe)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.1009 0.6032 0.8985 1.0000 1.2649 6.0391 hist(log10(sizeFactors(spe)), xlab = &quot;log10 (size factors)&quot;, main = &quot;Size factors&quot;) # calculate logcounts (log-transformed normalized counts) and store in object spe &lt;- logNormCounts(spe) assayNames(spe) ## [1] &quot;counts&quot; &quot;logcounts&quot; 17.6 Feature selection Identify a set of top highly variable genes (HVGs), which will be used to define cell types. We use methods from scran (Lun, McCarthy, and Marioni 2016), and first filter out mitochondrial genes (since these are very highly expressed and not of biological interest here). # remove mitochondrial genes spe &lt;- spe[!is_mito, ] dim(spe) ## [1] 32272 2683 # fit mean-variance relationship dec &lt;- modelGeneVar(spe) # visualize mean-variance relationship fit &lt;- metadata(dec) plot(fit$mean, fit$var, xlab = &quot;mean of log-expression&quot;, ylab = &quot;variance of log-expression&quot;) curve(fit$trend(x), col = &quot;dodgerblue&quot;, add = TRUE, lwd = 2) # select top HVGs top_hvgs &lt;- getTopHVGs(dec, prop = 0.1) length(top_hvgs) ## [1] 1216 Note there are a few extremely highly expressed genes, which influence the fitted mean-variance relationship. We check the names of these genes to decide whether they should be removed as outliers. # identify outlier genes rev(sort(fit$mean))[1:3] ## ENSMUSG00000115783 ENSMUSG00000098178 ENSMUSG00000024661 ## 10.992042 9.904624 7.370274 outlier_ids &lt;- names(rev(sort(fit$mean))[1:3]) rowData(spe)[outlier_ids, ] ## DataFrame with 3 rows and 3 columns ## gene_id gene_name feature_type ## &lt;character&gt; &lt;character&gt; &lt;character&gt; ## ENSMUSG00000115783 ENSMUSG00000115783 Bc1 Gene Expression ## ENSMUSG00000098178 ENSMUSG00000098178 Gm42418 Gene Expression ## ENSMUSG00000024661 ENSMUSG00000024661 Fth1 Gene Expression These appear to be biologically meaningful genes, so we leave them in. 17.7 Dimensionality reduction Run principal component analysis (PCA) using scater (McCarthy et al. 2017), and retain the top 50 principal components (PCs) for downstream analyses. Also run UMAP on the top 50 PCs, and retain the top 2 UMAP components for visualization purposes. # compute PCA set.seed(123) spe &lt;- runPCA(spe, subset_row = top_hvgs) reducedDimNames(spe) ## [1] &quot;PCA&quot; dim(reducedDim(spe, &quot;PCA&quot;)) ## [1] 2683 50 # compute UMAP on top 50 PCs set.seed(123) spe &lt;- runUMAP(spe, dimred = &quot;PCA&quot;) reducedDimNames(spe) ## [1] &quot;PCA&quot; &quot;UMAP&quot; dim(reducedDim(spe, &quot;UMAP&quot;)) ## [1] 2683 2 # update column names for plotting functions colnames(reducedDim(spe, &quot;UMAP&quot;)) &lt;- paste0(&quot;UMAP&quot;, 1:2) 17.8 Clustering Perform clustering to define cell types. We apply graph-based clustering using the Walktrap method implemented in scran (Lun, McCarthy, and Marioni 2016), applied to the top 50 PCs calculated on the set of top HVGs. # graph-based clustering set.seed(123) k &lt;- 10 g &lt;- buildSNNGraph(spe, k = k, use.dimred = &quot;PCA&quot;) g_walk &lt;- igraph::cluster_walktrap(g) clus &lt;- g_walk$membership table(clus) ## clus ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## 125 126 61 229 241 283 165 132 161 267 122 43 99 94 101 161 26 58 64 24 ## 21 22 23 ## 51 32 18 # store cluster labels in column &#39;label&#39; in colData colLabels(spe) &lt;- factor(clus) Visualize the clusters by plotting in (i) spatial x-y coordinates on the tissue slide, and (ii) UMAP dimensions. We use plotting functions from the ggspavis package. library(ggspavis) # define custom color palette colors &lt;- unname(palette.colors(palette = &quot;Polychrome 36&quot;)) # plot clusters in spatial x-y coordinates plotSpots(spe, discrete = &quot;label&quot;, palette = colors) # plot clusters in UMAP dimensions plotDimRed(spe, type = &quot;UMAP&quot;, discrete = &quot;label&quot;, palette = colors) 17.9 Marker genes Identify marker genes by testing for differential gene expression between clusters, using the binomial test implemented in findMarkers in scran (Lun, McCarthy, and Marioni 2016). # set gene names as row names for visualization purposes rownames(spe) &lt;- rowData(spe)$gene_name # test for marker genes markers &lt;- findMarkers(spe, test = &quot;binom&quot;, direction = &quot;up&quot;) # returns a list with one DataFrame per cluster markers ## List of length 23 ## names(23): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(pheatmap) # plot log-fold changes for one cluster over all other clusters # selecting cluster 5 interesting &lt;- markers[[5]] best_set &lt;- interesting[interesting$Top &lt;= 5, ] logFCs &lt;- getMarkerEffects(best_set) pheatmap(logFCs, breaks = seq(-5, 5, length.out = 101)) # plot log-transformed normalized expression of top genes for one cluster top_genes &lt;- head(rownames(interesting)) plotExpression(spe, x = &quot;label&quot;, features = top_genes) "],["contributors.html", "Chapter 18 Contributors", " Chapter 18 Contributors Lukas M. Weber, Johns Hopkins Bloomberg School of Public Health, Baltimore, MD, USA Abby Spangler, Lieber Institute for Brain Development, Baltimore, MD, USA Brenda Pardo, Lieber Institute for Brain Development, Baltimore, MD, USA Leonardo Collado-Torres, Lieber Institute for Brain Development, Baltimore, MD, USA Stephanie C. Hicks, Johns Hopkins Bloomberg School of Public Health, Baltimore, MD, USA "],["references.html", "Chapter 19 References", " Chapter 19 References Lun, Aaron T L, Davis J McCarthy, and John C Marioni. 2016. “A Step-by-Step Workflow for Low-Level Analysis of Single-Cell RNA-seq Data with Bioconductor.” F1000Research 5: 2122. Maynard, K R, L Collado-Torres, L M Weber, C Uytingco, B K Barry, S R Williams, J L Catallini, et al. 2021. “Transcriptome-Scale Spatial Gene Expression in the Human Dorsolateral Prefrontal Cortex.” Nature Neuroscience, 425–36. McCarthy, Davis J, Kieran R Campbell, Aaron T L Lun, and Quin F Wills. 2017. “Scater: Pre-Processing, Quality Control, Normalization and Visualization of Single-Cell RNA-seq Data in R.” Bioinformatics 33 (8): 1179–86. McInnes, Leland, John Healy, and James Melville. 2018. “UMAP: Uniform Manifold Approximation and Projection for Dimension Reduction.” arXiv 1802.03426 (v2). Sun, Shiquan, Jiaqiang Zhu, and Xiang Zhou. 2020. “Statistical Analysis of Spatial Expression Patterns for Spatially Resolved Transcriptomic Studies.” Nature Methods 17 (2): 193–200. Svensson, Valentine, Sarah A Teichmann, and Oliver Stegle. 2018. “SpatialDE: Identification of Spatially Variable Genes.” Nature Methods 15 (5): 343–46. Zhao, Edward, Matthew R. Stone, Xing Ren, Thomas Pulliam, Paul Nghiem, Jason H. Bielas, and Raphael Gottardo. 2020. “BayesSpace Enables the Robust Characterization of Spatial Gene Expression Architecture in Tissue Sections at Increased Resolution.” bioRxiv. "]]
